(function(e){var t;define([],function(){return function(){describe("Binding dependencies",function(){beforeEach(jasmine.prepareTestNode),it("If the binding handler depends on an observable, invokes the init handler once and the update handler whenever a new value is available",function(){var e=new ko.observable,t=[],n=[];ko.bindingHandlers.test={init:function(e,n){t.push(n()())},update:function(e,t){n.push(t()())}},testNode.innerHTML="<div data-bind='test: myObservable'></div>",ko.applyBindings({myObservable:e},testNode),expect(t.length).toEqual(1),expect(n.length).toEqual(1),expect(t[0]).toBeUndefined(),expect(n[0]).toBeUndefined(),e("A"),expect(t.length).toEqual(1),expect(n.length).toEqual(2),expect(n[1]).toEqual("A")}),it("If the associated DOM element was removed by KO, handler subscriptions are disposed immediately",function(){var e=new ko.observable("A");ko.bindingHandlers.anyHandler={update:function(e,t){t()}},testNode.innerHTML="<div data-bind='anyHandler: myObservable()'></div>",ko.applyBindings({myObservable:e},testNode),expect(e.getSubscriptionsCount()).toEqual(1),ko.removeNode(testNode),expect(e.getSubscriptionsCount()).toEqual(0)}),it("If the associated DOM element was removed independently of KO, handler subscriptions are disposed on the next evaluation",function(){var e=new ko.observable("A");ko.bindingHandlers.anyHandler={update:function(e,t){t()}},testNode.innerHTML="<div data-bind='anyHandler: myObservable()'></div>",ko.applyBindings({myObservable:e},testNode),expect(e.getSubscriptionsCount()).toEqual(1),testNode.parentNode.removeChild(testNode),e("B"),expect(e.getSubscriptionsCount()).toEqual(0)}),it("If the binding attribute involves an observable, re-invokes the bindings if the observable notifies a change",function(){var e=new ko.observable({message:"hello"}),t=[];ko.bindingHandlers.test={update:function(e,n){t.push(n())}},testNode.innerHTML="<div data-bind='test: myObservable().message'></div>",ko.applyBindings({myObservable:e},testNode),expect(t.length).toEqual(1),expect(t[0]).toEqual("hello"),e({message:"goodbye"}),expect(t.length).toEqual(2),expect(t[1]).toEqual("goodbye")}),it("Should not reinvoke init for notifications triggered during first evaluation",function(){var e=ko.observable("A"),t=0;ko.bindingHandlers.test={init:function(e,n){t++;var r=n();r(),r("B")}},testNode.innerHTML="<div data-bind='test: myObservable'></div>",ko.applyBindings({myObservable:e},testNode),expect(t).toEqual(1)}),it("Should not run update before init, even if an associated observable is updated by a different binding before init",function(){var e=ko.observable("A"),t=!1,n=!1;ko.bindingHandlers.test1={init:function(e,t){var n=t();n(),n("B")}},ko.bindingHandlers.test2={init:function(){t=!0},update:function(){if(!t)throw new Error("Called 'update' before 'init'");n=!0}},testNode.innerHTML="<div data-bind='test1: myObservable, test2: true'></div>",ko.applyBindings({myObservable:e},testNode),expect(n).toEqual(!0)}),it("Should be able to get all updates to observables in both init and update",function(){var e,t;ko.bindingHandlers.testInit={init:function(t,n){ko.dependentObservable(function(){e=ko.utils.unwrapObservable(n())})}},ko.bindingHandlers.testUpdate={update:function(e,n){t=ko.utils.unwrapObservable(n())}},testNode.innerHTML="<div data-bind='testInit: myProp()'></div><div data-bind='testUpdate: myProp()'></div>";var n=ko.observable({myProp:ko.observable("initial value")});ko.applyBindings(n,testNode),expect(e).toEqual("initial value"),expect(t).toEqual("initial value"),n().myProp("second value"),expect(e).toEqual("second value"),expect(t).toEqual("second value"),n().myProp(ko.observable("third value")),expect(e).toEqual("third value"),expect(t).toEqual("third value"),n({myProp:function(){return"fourth value"}}),expect(e).toEqual("fourth value"),expect(t).toEqual("fourth value")}),it("Should not update sibling bindings if a binding is updated",function(){var e=0,t=ko.observable(1);ko.bindingHandlers.countingHandler={update:function(){e++}},ko.bindingHandlers.unwrappingHandler={update:function(e,t){t()}},testNode.innerHTML="<div data-bind='countingHandler: true, unwrappingHandler: myObservable()'></div>",ko.applyBindings({myObservable:t},testNode),expect(e).toEqual(1),t(3),expect(e).toEqual(1)}),it("Should not subscribe to observables accessed in init function",function(){var e=ko.observable("A");ko.bindingHandlers.test={init:function(e,t){var n=t();n()}},testNode.innerHTML="<div data-bind='if: true'><div data-bind='test: myObservable'></div></div>",ko.applyBindings({myObservable:e},testNode),expect(e.getSubscriptionsCount()).toEqual(0)}),it("Should access latest value from extra binding when normal binding is updated",function(){delete ko.bindingHandlers.nonexistentHandler;var e=ko.observable(),t,n={myObservable:e,myNonObservable:"first value"};ko.bindingHandlers.existentHandler={update:function(e,n,r){n()(),t=r.get("nonexistentHandler")}},testNode.innerHTML="<div data-bind='existentHandler: myObservable, nonexistentHandler: myNonObservable'></div>",ko.applyBindings(n,testNode),expect(t).toEqual("first value"),n.myNonObservable="second value",e.notifySubscribers(),expect(t).toEqual("second value")}),it("Should update a binding when its observable is modified in a sibling binding",function(){var e,t=ko.observable(1),n=ko.observable();ko.bindingHandlers.updatedHandler={update:function(){e=n()}},ko.bindingHandlers.modifyingHandler={update:function(){n(t())}},testNode.innerHTML="<div data-bind='updatedHandler: true, modifyingHandler: true'></div>",ko.applyBindings({},testNode),expect(e).toEqual(1),t(2),expect(e).toEqual(2)}),it('Should track observables accessed within the binding provider\'s "getBindingAccessor" function',function(){this.restoreAfter(ko.bindingProvider,"instance");var e=ko.observable("substitute"),t=ko.bindingProvider.instance;ko.bindingProvider.instance={nodeHasBindings:t.nodeHasBindings,getBindingAccessors:function(n,r){var i=t.getBindingAccessors(n,r);if(i&&i.text){var s=e();i.text=function(){return s}}return i}},testNode.innerHTML="<div data-bind='text: \"hello\"'></div>",ko.applyBindings({},testNode),expect(testNode).toContainText("substitute"),expect(e.getSubscriptionsCount()).toEqual(1),e("new value"),expect(testNode).toContainText("new value")}),describe("Observable view models",function(){it("Should update bindings (including callbacks)",function(){function n(e){t=e}var e=ko.observable(),t;testNode.innerHTML="<div><input data-bind='value:someProp' /><input type='button' data-bind='click: checkVM' /></div>",e({someProp:"My prop value",checkVM:n}),ko.applyBindings(e,testNode),expect(e.getSubscriptionsCount()).toEqual(1),expect(testNode.childNodes[0].childNodes[0].value).toEqual("My prop value"),testNode.childNodes[0].childNodes[0].value="some user-entered value",ko.utils.triggerEvent(testNode.childNodes[0].childNodes[0],"change"),expect(e().someProp).toEqual("some user-entered value"),ko.utils.triggerEvent(testNode.childNodes[0].childNodes[1],"click"),expect(t).toEqual(e()),e({someProp:ko.observable("My new prop value"),checkVM:n}),expect(testNode.childNodes[0].childNodes[0].value).toEqual("My new prop value"),testNode.childNodes[0].childNodes[0].value="some new user-entered value",ko.utils.triggerEvent(testNode.childNodes[0].childNodes[0],"change"),expect(e().someProp()).toEqual("some new user-entered value"),ko.utils.triggerEvent(testNode.childNodes[0].childNodes[1],"click"),expect(t).toEqual(e()),ko.removeNode(testNode),e(null),expect(e.getSubscriptionsCount()).toEqual(0)}),it("Should provide access to the view model's observable through $rawData",function(){var e=ko.observable("text");testNode.innerHTML="<div data-bind='text:$data'></div>",ko.applyBindings(e,testNode),expect(testNode).toContainText("text");var t=ko.contextFor(testNode);expect(t.$data).toEqual("text"),expect(t.$rawData).toBe(e)}),it("Should set $rawData to the observable returned from a function",function(){var e=ko.observable("text");testNode.innerHTML="<div data-bind='text:$data'></div>",ko.applyBindings(function(){return e},testNode),expect(testNode).toContainText("text");var t=ko.contextFor(testNode);expect(t.$data).toEqual("text"),expect(t.$rawData).toBe(e)}),it("Should set $rawData to the view model if a function unwraps the observable view model",function(){var e=ko.observable("text");testNode.innerHTML="<div data-bind='text:$data'></div>",ko.applyBindings(function(){return e()},testNode),expect(testNode).toContainText("text");var t=ko.contextFor(testNode);expect(t.$data).toEqual("text"),expect(t.$rawData).toBe("text"),e("new text"),expect(testNode).toContainText("new text"),expect(t.$data).toEqual("new text"),expect(t.$rawData).toBe("new text")}),it("Should dispose view model subscription on next update when bound node is removed outside of KO",function(){var e=ko.observable("text");testNode.innerHTML="<div data-bind='text:$data'></div>",ko.applyBindings(e,testNode),expect(e.getSubscriptionsCount()).toEqual(1),testNode.parentNode.removeChild(testNode),e(null),expect(e.getSubscriptionsCount()).toEqual(0)}),it("Should update all child contexts (including values copied from the parent)",function(){ko.bindingHandlers.setChildContext={init:function(e,t,n,r,i){return ko.applyBindingsToDescendants(i.createChildContext(function(){return ko.utils.unwrapObservable(t())}),e),{controlsDescendantBindings:!0}}},testNode.innerHTML="<div data-bind='setChildContext:obj1'><span data-bind='text:prop1'></span><span data-bind='text:$root.prop2'></span></div>";var e=ko.observable({obj1:{prop1:"First "},prop2:"view model"});ko.applyBindings(e,testNode),expect(testNode).toContainText("First view model"),e({obj1:{prop1:"Second view "},prop2:"model"}),expect(testNode).toContainText("Second view model"),e({obj1:{prop1:"Third view model"},prop2:""}),expect(testNode).toContainText("Third view model"),ko.removeNode(testNode),e(null),expect(e.getSubscriptionsCount()).toEqual(0)}),it("Should update all extended contexts (including values copied from the parent)",function(){ko.bindingHandlers.withProperties={init:function(e,t,n,r,i){var s=i.extend(t);return ko.applyBindingsToDescendants(s,e),{controlsDescendantBindings:!0}}},testNode.innerHTML="<div data-bind='withProperties: obj1'><span data-bind='text:prop1'></span><span data-bind='text:prop2'></span><span data-bind='text:$rawData().prop3'></span></div>";var e=ko.observable({obj1:{prop1:"First "},prop2:"view ",prop3:"model"});ko.applyBindings(e,testNode),expect(testNode).toContainText("First view model"),e({obj1:{prop1:"Second view "},prop2:"model",prop3:""}),expect(testNode).toContainText("Second view model"),e({obj1:{prop1:""},prop2:"",prop3:"Third view model"}),expect(testNode).toContainText("Third view model"),ko.removeNode(testNode),e(null),expect(e.getSubscriptionsCount()).toEqual(0)}),it("Should maintain correct $rawData in extended context when parent is bound to a function that returns an observable view model",function(){ko.bindingHandlers.extended={init:function(e,t,n,r,i){return ko.applyBindingsToDescendants(i.extend(t),e),{controlsDescendantBindings:!0}}};var e=ko.observable("vm1"),t=ko.observable("vm2"),n=ko.observable(e);testNode.innerHTML="<div data-bind='extended: {}'><div data-bind='text: $data'></div></div>",ko.applyBindings(function(){return n()},testNode),expect(testNode).toContainText("vm1");var r=ko.contextFor(testNode),i=ko.contextFor(testNode.childNodes[0].childNodes[0]);expect(r.$data).toEqual("vm1"),expect(r.$rawData).toBe(e),expect(i).not.toBe(r),expect(i.$data).toEqual("vm1"),expect(i.$rawData).toBe(e),n(t),expect(testNode).toContainText("vm2"),expect(i.$data).toEqual("vm2"),expect(i.$rawData).toBe(t)}),it("Should update an extended child context",function(){ko.bindingHandlers.withProperties={init:function(e,t,n,r,i){var s=i.createChildContext(null,null,function(e){ko.utils.extend(e,t())});return ko.applyBindingsToDescendants(s,e),{controlsDescendantBindings:!0}}},testNode.innerHTML="<div data-bind='withProperties: obj1'><span data-bind='text:prop1'></span><span data-bind='text:$parent.prop2'></span></div>";var e=ko.observable({obj1:{prop1:"First "},prop2:"view model"});ko.applyBindings(e,testNode),expect(testNode).toContainText("First view model"),e({obj1:{prop1:"Second view "},prop2:"model"}),expect(testNode).toContainText("Second view model"),e({obj1:{prop1:"Third view model"},prop2:""}),expect(testNode).toContainText("Third view model"),ko.removeNode(testNode),e(null),expect(e.getSubscriptionsCount()).toEqual(0)})}),describe("Order",function(){var e;beforeEach(function(){function t(t){return{init:function(){e.push(t)}}}e=[],ko.bindingHandlers.test1=t(1),ko.bindingHandlers.test2=t(2),ko.bindingHandlers.test3=t(3),ko.bindingHandlers.test4=t(4)}),it("Should default to the order in the binding",function(){testNode.innerHTML="<div data-bind='test1, test2, test3'></div>",ko.applyBindings(null,testNode),expect(e).toEqual([1,2,3])}),it('Should be based on binding\'s "after" values, which override the default binding order',function(){ko.bindingHandlers.test2.after=["test1"],ko.bindingHandlers.test3.after=["test2"],testNode.innerHTML="<div data-bind='test3, test2, test1'></div>",ko.applyBindings(null,testNode),expect(e).toEqual([1,2,3])}),it('Should leave bindings without an "after" value where they are',function(){ko.bindingHandlers.test2.after=["test1"],testNode.innerHTML="<div data-bind='test2, test1, test3'></div>",ko.applyBindings(null,testNode),expect(e).toEqual([1,2,3])}),it('Should leave bindings without an "after" value where they are (extended)',function(){ko.bindingHandlers.test2.after=["test1"],testNode.innerHTML="<div data-bind='test2, test3, test1'></div>",ko.applyBindings(null,testNode),expect(e).toEqualOneOf([[1,2,3],[3,1,2]])}),it("Should throw an error if bindings have a cyclic dependency",function(){ko.bindingHandlers.test1.after=["test3"],ko.bindingHandlers.test2.after=["test1"],ko.bindingHandlers.test3.after=["test4","test2"],ko.bindingHandlers.test4.after=[],testNode.innerHTML="<div data-bind='test1, unknownBinding, test2, test4, test3'></div>",expect(function(){ko.applyBindings(null,testNode)}).toThrow("Cannot combine the following bindings, because they have a cyclic dependency: test1, test3, test2")})})})}.call(e),t})})(this);