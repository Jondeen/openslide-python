(function(e){var t;define([],function(){return function(){describe("Pure Computed",function(){it("Should advertise that instances are computed",function(){var e=ko.pureComputed(function(){});expect(ko.isComputed(e)).toEqual(!0)}),it("Should require an evaluator function as constructor param",function(){expect(function(){ko.pureComputed()}).toThrow()}),it('Should be able to pass evaluator function using "options" parameter called "read"',function(){var e=ko.pureComputed({read:function(){return 123}});expect(e()).toEqual(123)}),it('Should not be able to write a value to it if there is no "write" callback',function(){var e=ko.pureComputed(function(){return 123});expect(ko.isWriteableObservable(e)).toEqual(!1),expect(function(){e(456)}).toThrow()}),it('Should invoke the "write" callback, where present, if you attempt to write a value to it',function(){var e,t=ko.pureComputed({read:function(){},write:function(t){e=t}});expect(ko.isWriteableObservable(t)).toEqual(!0),t("some value"),expect(e).toEqual("some value")}),it("Should describe itself as active initially",function(){var e=ko.pureComputed(function(){});expect(e.isActive()).toEqual(!0)}),it("Should describe itself as inactive if the evaluator has no dependencies on its first run",function(){var e=ko.pureComputed(function(){});e(),expect(e.isActive()).toEqual(!1)}),it("Should describe itself as active if the evaluator has dependencies on its first run",function(){var e=ko.observable("initial"),t=ko.computed(e);t(),expect(t.isActive()).toEqual(!0)}),it("Should evaluate on each access while sleeping when dependencies have changed",function(){var e=0,t=ko.observable("A"),n=ko.pureComputed(function(){return++e,t()});expect(e).toEqual(0),expect(n()).toEqual("A"),expect(e).toEqual(1),t("B"),expect(n()).toEqual("B"),expect(e).toEqual(2),t("C"),expect(n.peek()).toEqual("C"),expect(e).toEqual(3),expect(n()).toEqual("C"),expect(e).toEqual(3)}),it("Should not subscribe to dependencies while sleeping",function(){var e=ko.observable("A"),t=ko.pureComputed(e);expect(t()).toEqual("A"),expect(e.getSubscriptionsCount()).toEqual(0),expect(t.getDependenciesCount()).toEqual(1)}),it("Should not evaluate after it has been disposed",function(){var e=0,t=ko.observable("A"),n=ko.pureComputed(function(){return++e,t()});expect(n()).toEqual("A"),expect(e).toEqual(1),n.dispose(),expect(n.isActive()).toEqual(!1),t("B"),expect(n()).toEqual("A"),expect(e).toEqual(1)}),it("Should awaken and perform dependency detection when subscribed to",function(){var e=ko.observable("A"),t=ko.pureComputed(e),n=[];t.subscribe(function(e){n.push(e)}),expect(e.getSubscriptionsCount()).toEqual(1),expect(t.getDependenciesCount()).toEqual(1),expect(n).toEqual([]),e("B"),expect(n).toEqual(["B"])}),it("Should go back to sleep when all subcriptions are disposed",function(){var e=ko.observable("A"),t=ko.pureComputed(e),n=t.subscribe(function(){});expect(e.getSubscriptionsCount()).toEqual(1),expect(t.getDependenciesCount()).toEqual(1),n.dispose(),expect(e.getSubscriptionsCount()).toEqual(0),expect(t.getDependenciesCount()).toEqual(1)}),it('Should fire "awake" and "asleep" events when changing state',function(){var e=ko.observable("A"),t=ko.pureComputed(e),n=jasmine.createSpy("notifySpy");t.subscribe(n.bind(null,"awake"),null,"awake"),t.subscribe(n.bind(null,"asleep"),null,"asleep"),expect(e.getSubscriptionsCount()).toEqual(0);var r=t.subscribe(function(){});expect(n.argsForCall).toEqual([["awake","A"]]),expect(e.getSubscriptionsCount()).toEqual(1),n.reset(),e("B"),expect(n).not.toHaveBeenCalled(),r.dispose(),expect(n.argsForCall).toEqual([["asleep",undefined]]),expect(e.getSubscriptionsCount()).toEqual(0)}),it("Should subscribe to dependencies when awakened while minimizing evaluations",function(){var e=0,t=ko.observable("A"),n=ko.pureComputed(function(){return++e,t()}),r=[],i=function(e){r.push(e)},s;expect(e).toEqual(0),expect(n()).toEqual("A"),expect(e).toEqual(1),expect(n.getDependenciesCount()).toEqual(1),s=n.subscribe(i),expect(t.getSubscriptionsCount()).toEqual(1),expect(e).toEqual(1),s.dispose(),expect(n()).toEqual("A"),expect(e).toEqual(1),t("B"),expect(e).toEqual(1),s=n.subscribe(i),expect(e).toEqual(2),expect(r).toEqual([]),t("C"),expect(e).toEqual(3),expect(r).toEqual(["C"])}),it("Should minimize evaluations when accessed from a computed",function(){var e=0,t=ko.observable("A"),n=ko.pureComputed(function(){return++e,t()}),r=ko.computed(n);expect(r()).toEqual("A"),expect(e).toEqual(1),t("B"),expect(r()).toEqual("B"),expect(e).toEqual(2),r.dispose(),expect(t.getSubscriptionsCount()).toEqual(0)}),it("Should evaluate latest value when chaining pure computeds",function(){var e=ko.observable("A"),t=ko.pureComputed(e),n=ko.pureComputed(t);expect(n()).toEqual("A"),e("B"),expect(n()).toEqual("B")}),it("Should minimize evaluations when chaining pure computeds",function(){var e=0,t=ko.observable("A"),n=ko.pureComputed(function(){return t()<="M"}),r=ko.pureComputed(function(){return++e,n()});expect(r()).toEqual(!0),expect(e).toEqual(1),t("B"),expect(r()).toEqual(!0),expect(e).toEqual(1),t("Z"),expect(r()).toEqual(!1),expect(e).toEqual(2)}),it("Should be able to re-evaluate a sleeping computed that previously threw an exception",function(){var e=ko.observable(!1),t=ko.observable(1),n=ko.pureComputed(function(){if(e())throw Error("Error during computed evaluation");return t()});expect(n()).toEqual(1),t(2),e(!0),expect(n).toThrow("Error during computed evaluation"),e(!1),expect(n()).toEqual(2)}),it("Should prevent recursive calling of read function",function(){var e=ko.observable("A"),t=ko.pureComputed(function(){return""+e()+t()});expect(t).toThrow(),e("B"),expect(function(){ko.computed(t)}).toThrow()}),it("Should not add dependencies if disposed during evaluation while sleeping",function(){var e=0,t=ko.observable(!1),n=ko.observable("A"),r=ko.pureComputed(function(){return t()&&r.dispose(),++e,n()});expect(r()).toEqual("A"),expect(e).toEqual(1),expect(r.getDependenciesCount()).toEqual(2),t(!0),expect(r()).toEqual("A"),expect(e).toEqual(2),expect(r.getDependenciesCount()).toEqual(0)}),describe("Should maintain order of subscriptions",function(){function n(t,n,r){var i=[];t.subscribe(function(e){i.push(e)}),e(n),expect(i).toEqual(r)}var e,t;beforeEach(function(){e=ko.observable("A"),ko.computed(e),t=ko.pureComputed(e)}),it("base behavior: order is pure computed, observable",function(){var r=ko.pureComputed(function(){return t()+e()});n(r,"B",["BB"])}),it("base behavior: order is observable, pure computed",function(){var r=ko.pureComputed(function(){return e()+t()});n(r,"B",["BA","BB"])}),it("when awakening, without re-evaluation",function(){var r=0,i=ko.pureComputed(function(){return++r,t()+e()});expect(i()).toEqual("AA"),expect(r).toEqual(1),n(i,"B",["BB"]),expect(r).toEqual(3)})}),describe("Context",function(){it("Should not define initial evaluation",function(){var e=ko.observable(1),t=0,n=ko.pureComputed(function(){return++t,e(),ko.computedContext.isInitial()});expect(t).toEqual(0),expect(n()).toEqual(undefined),expect(t).toEqual(1),e(2),ko.computed(n),expect(t).toEqual(2),expect(n()).toEqual(undefined)}),it("Should accurately report the number of dependencies",function(){var e=ko.observable(1),t=ko.observable(1),n=0,r=ko.pureComputed(function(){return expect(ko.computedContext.getDependenciesCount()).toEqual(0),e(),expect(ko.computedContext.getDependenciesCount()).toEqual(1),t(),expect(ko.computedContext.getDependenciesCount()).toEqual(2),e(),expect(ko.computedContext.getDependenciesCount()).toEqual(2),++n});expect(r()).toEqual(1),expect(r.getDependenciesCount()).toEqual(2),e(2),expect(r()).toEqual(2),expect(r.getDependenciesCount()).toEqual(2)})})})}.call(e),t})})(this);