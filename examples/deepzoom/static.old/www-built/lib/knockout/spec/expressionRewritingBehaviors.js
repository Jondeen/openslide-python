(function(root){var amdExports;define([],function(){return function(){describe("Expression Rewriting",function(){it("Should be able to parse simple object literals",function(){var e=ko.expressionRewriting.parseObjectLiteral("a: 1, b: 2, \"quotedKey\": 3, 'aposQuotedKey': 4");expect(e.length).toEqual(4),expect(e[0].key).toEqual("a"),expect(e[0].value).toEqual("1"),expect(e[1].key).toEqual("b"),expect(e[1].value).toEqual("2"),expect(e[2].key).toEqual("quotedKey"),expect(e[2].value).toEqual("3"),expect(e[3].key).toEqual("aposQuotedKey"),expect(e[3].value).toEqual("4")}),it("Should ignore any outer braces",function(){var e=ko.expressionRewriting.parseObjectLiteral("{a: 1}");expect(e.length).toEqual(1),expect(e[0].key).toEqual("a"),expect(e[0].value).toEqual("1")}),it("Should be able to parse object literals containing string literals",function(){var e=ko.expressionRewriting.parseObjectLiteral("a: \"comma, colon: brace{ bracket[ apos' escapedQuot\\\" end\", b: 'escapedApos\\' brace} bracket] quot\"'");expect(e.length).toEqual(2),expect(e[0].key).toEqual("a"),expect(e[0].value).toEqual('"comma, colon: brace{ bracket[ apos\' escapedQuot\\" end"'),expect(e[1].key).toEqual("b"),expect(e[1].value).toEqual("'escapedApos\\' brace} bracket] quot\"'")}),it("Should be able to parse object literals containing child objects, arrays, function literals, and newlines",function(){var e=ko.expressionRewriting.parseObjectLiteral("myObject:{someChild:{},someChildArray:[1,2,3],\"quotedChildProp\":'string value'},\nsomeFn:function(a,b,c){var regex=/{/;var str='/})({';return{};},myArray:[{},function(){},\"my'Str\",'my\"Str']");expect(e.length).toEqual(3),expect(e[0].key).toEqual("myObject"),expect(e[0].value).toEqual("{someChild:{},someChildArray:[1,2,3],\"quotedChildProp\":'string value'}"),expect(e[1].key).toEqual("someFn"),expect(e[1].value).toEqual("function(a,b,c){var regex=/{/;var str='/})({';return{};}"),expect(e[2].key).toEqual("myArray"),expect(e[2].value).toEqual("[{},function(){},\"my'Str\",'my\"Str']")}),it("Should be able to parse object literals containing division and regular expressions",function(){var e=ko.expressionRewriting.parseObjectLiteral("div: null/5, regexpFunc: function(){var regex=/{/g;return /123/;}");expect(e.length).toEqual(2),expect(e[0].key).toEqual("div"),expect(e[0].value).toEqual("null/5"),expect(e[1].key).toEqual("regexpFunc"),expect(e[1].value).toEqual("function(){var regex=/{/g;return/123/;}")}),it("Should parse a value that begins with a colon",function(){var e=ko.expressionRewriting.parseObjectLiteral("a: :-)");expect(e.length).toEqual(1),expect(e[0].key).toEqual("a"),expect(e[0].value).toEqual(":-)")}),it("Should be able to cope with malformed syntax (things that aren't key-value pairs)",function(){var e=ko.expressionRewriting.parseObjectLiteral("malformed1, 'mal:formed2', good:3, {malformed:4}, good5:5, keyonly:");expect(e.length).toEqual(6),expect(e[0].unknown).toEqual("malformed1"),expect(e[1].unknown).toEqual("mal:formed2"),expect(e[2].key).toEqual("good"),expect(e[2].value).toEqual("3"),expect(e[3].unknown).toEqual("{malformed:4}"),expect(e[4].key).toEqual("good5"),expect(e[4].value).toEqual("5"),expect(e[5].unknown).toEqual("keyonly")}),it("Should ensure all keys are wrapped in quotes",function(){var e=ko.expressionRewriting.preProcessBindings("a: 1, 'b': 2, \"c\": 3");expect(e).toEqual("'a':1,'b':2,'c':3")}),it("(Private API) Should convert writable values to property accessors",function(){var w=ko.expressionRewriting._twoWayBindings;w.a=w.b=w.c=w.d=w.e=w.f=w.g=w.h=w.i=w.j=!0;var rewritten=ko.expressionRewriting.preProcessBindings('a : 1, b : firstName, c : function() { return "returnValue"; }, d: firstName+lastName, e: boss.firstName, f: boss . lastName, g: getAssitant(), h: getAssitant().firstName, i: getAssitant("[dummy]")[ "lastName" ], j: boss.firstName + boss.lastName');w.a=w.b=w.c=w.d=w.e=w.f=w.g=w.h=w.i=w.j=!1;var assistant={firstName:"john",lastName:"english"},model={firstName:"bob",lastName:"smith",boss:{firstName:"rick",lastName:"martin"},getAssitant:function(){return assistant}};with(model){var parsed=eval("({"+rewritten+"})");expect(parsed.a).toEqual(1),expect(parsed.b).toEqual("bob"),expect(parsed.c()).toEqual("returnValue"),expect(parsed.d).toEqual("bobsmith"),expect(parsed.e).toEqual("rick"),expect(parsed.f).toEqual("martin"),expect(parsed.g).toEqual(assistant),expect(parsed.h).toEqual("john"),expect(parsed.i).toEqual("english"),expect(parsed._ko_property_writers).toHaveOwnProperties(["b","e","f","h","i","j"]),parsed._ko_property_writers.b("bob2"),expect(model.firstName).toEqual("bob2"),parsed._ko_property_writers.e("rick2"),expect(model.boss.firstName).toEqual("rick2"),parsed._ko_property_writers.f("martin2"),expect(model.boss.lastName).toEqual("martin2"),parsed._ko_property_writers.h("john2"),expect(assistant.firstName).toEqual("john2"),parsed._ko_property_writers.i("english2"),expect(assistant.lastName).toEqual("english2"),parsed._ko_property_writers.j("nothing at all"),expect(model.boss.firstName).toEqual("rick2"),expect(model.boss.lastName).toEqual("martin2")}}),it("Should be able to eval rewritten literals that contain unquoted keywords as keys",function(){var rewritten=ko.expressionRewriting.preProcessBindings("if: true");expect(rewritten).toEqual("'if':true");var evaluated=eval("({"+rewritten+"})");expect(evaluated["if"]).toEqual(!0)}),it("Should eval keys without a value as if the value is undefined",function(){var rewritten=ko.expressionRewriting.preProcessBindings("a: 1, b"),parsedRewritten=eval("({"+rewritten+"})");expect(parsedRewritten.a).toEqual(1),expect("b"in parsedRewritten).toBeTruthy(),expect(parsedRewritten.b).toBeUndefined()}),it("Should return accessor functions for each value when called with the valueAccessors option",function(){var rewritten=ko.expressionRewriting.preProcessBindings("a: 1",{valueAccessors:!0});expect(rewritten).toEqual("'a':function(){return 1 }");var evaluated=eval("({"+rewritten+"})");expect(evaluated.a()).toEqual(1)}),it("Should be able to parse and evaluate object literals containing division",function(){var result=ko.expressionRewriting.parseObjectLiteral("a: null/1, b: 2/1, c: (6) / 2, d: '2'/2, r: /a regex/");expect(result).toEqual([{key:"a",value:"null/1"},{key:"b",value:"2/1"},{key:"c",value:"(6)/2"},{key:"d",value:"'2'/2"},{key:"r",value:"/a regex/"}]);var rewritten=ko.expressionRewriting.preProcessBindings(result,{valueAccessors:!0}),evaluated=eval("({"+rewritten+"})");expect(evaluated.a()).toEqual(0),expect(evaluated.b()).toEqual(2),expect(evaluated.c()).toEqual(3),expect(evaluated.d()).toEqual(1)})})}.call(root),amdExports})})(this);