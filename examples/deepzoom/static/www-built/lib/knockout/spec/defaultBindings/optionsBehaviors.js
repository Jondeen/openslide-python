(function(e){var t;define([],function(){return function(){describe("Binding: Options",function(){beforeEach(jasmine.prepareTestNode),it("Should only be applicable to SELECT nodes",function(){var e=!1;testNode.innerHTML="<input data-bind='options:{}' />";try{ko.applyBindings({},testNode)}catch(t){e=!0}expect(e).toEqual(!0)}),it("Should set the SELECT node's options set to match the model value",function(){var e=new ko.observableArray(["A","B","C"]);testNode.innerHTML="<select data-bind='options:myValues'><option>should be deleted</option></select>",ko.applyBindings({myValues:e},testNode),expect(testNode.childNodes[0]).toHaveTexts(["A","B","C"])}),it("Should accept optionsText and optionsValue params to display subproperties of the model values",function(){var e=new ko.observableArray([{name:"bob",id:ko.observable(6)},{name:ko.observable("frank"),id:13}]);testNode.innerHTML='<select data-bind=\'options:myValues, optionsText: "name", optionsValue: "id"\'><option>should be deleted</option></select>',ko.applyBindings({myValues:e},testNode),expect(testNode.childNodes[0]).toHaveTexts(["bob","frank"]),expect(testNode.childNodes[0]).toHaveValues(["6","13"])}),it("Should accept function in optionsText param to display subproperties of the model values",function(){var e=new ko.observableArray([{name:"bob",job:"manager"},{name:"frank",job:"coder & tester"}]);testNode.innerHTML='<select data-bind=\'options:myValues, optionsText: function (v) { return v["name"] + " (" + v["job"] + ")"; }\'><option>should be deleted</option></select>',ko.applyBindings({myValues:e},testNode),expect(testNode.childNodes[0]).toHaveTexts(["bob (manager)","frank (coder & tester)"])}),it("Should accept a function in optionsValue param to select subproperties of the model values (and use that for the option text)",function(){var e=new ko.observableArray([{name:"bob",job:"manager"},{name:"frank",job:"coder & tester"}]);testNode.innerHTML='<select data-bind=\'options: myValues, optionsValue: function (v) { return v.name + " (" + v.job + ")"; }\'><option>should be deleted</option></select>',ko.applyBindings({myValues:e},testNode),expect(testNode.childNodes[0]).toHaveValues(["bob (manager)","frank (coder & tester)"]),expect(testNode.childNodes[0]).toHaveTexts(["bob (manager)","frank (coder & tester)"])}),it("Should exclude any items marked as destroyed",function(){var e=new ko.observableArray([{name:"bob",_destroy:!0},{name:"frank"}]);testNode.innerHTML="<select data-bind='options: myValues, optionsValue: \"name\"'></select>",ko.applyBindings({myValues:e},testNode),expect(testNode.childNodes[0]).toHaveValues(["frank"])}),it("Should include items marked as destroyed if optionsIncludeDestroyed is set",function(){var e=new ko.observableArray([{name:"bob",_destroy:!0},{name:"frank"}]);testNode.innerHTML="<select data-bind='options: myValues, optionsValue: \"name\", optionsIncludeDestroyed: true'></select>",ko.applyBindings({myValues:e},testNode),expect(testNode.childNodes[0]).toHaveValues(["bob","frank"])}),it("Should update the SELECT node's options if the model changes",function(){var e=new ko.observableArray(["A","B","C"]);testNode.innerHTML="<select data-bind='options:myValues'><option>should be deleted</option></select>",ko.applyBindings({myValues:e},testNode),e.splice(1,1),expect(testNode.childNodes[0]).toHaveTexts(["A","C"])}),it("Should retain as much selection as possible when changing the SELECT node's options",function(){var e=new ko.observableArray(["A","B","C"]);testNode.innerHTML="<select data-bind='options:myValues' multiple='multiple'></select>",ko.applyBindings({myValues:e},testNode),testNode.childNodes[0].options[1].selected=!0,expect(testNode.childNodes[0]).toHaveSelectedValues(["B"]),e(["B","C","A"]),expect(testNode.childNodes[0]).toHaveSelectedValues(["B"])}),it('Should retain selection when replacing the options data with new objects that have the same "value"',function(){var e=new ko.observableArray([{x:"A"},{x:"B"},{x:"C"}]);testNode.innerHTML="<select data-bind='options:myValues, optionsValue:\"x\"' multiple='multiple'></select>",ko.applyBindings({myValues:e},testNode),testNode.childNodes[0].options[1].selected=!0,expect(testNode.childNodes[0]).toHaveSelectedValues(["B"]),e([{x:"A"},{x:"C"},{x:"B"}]),expect(testNode.childNodes[0]).toHaveSelectedValues(["B"])}),it("Should select first option when removing the selected option and the original first option",function(){testNode.innerHTML="<select data-bind=\"options: filterValues, optionsText: 'x', optionsValue: 'x'\">";var e={filterValues:ko.observableArray([{x:1},{x:2},{x:3}])};ko.applyBindings(e,testNode),testNode.childNodes[0].options[1].selected=!0,expect(testNode.childNodes[0]).toHaveSelectedValues([2]),e.filterValues.splice(0,2,{x:4}),expect(testNode.childNodes[0]).toHaveSelectedValues([4])}),it("Should select caption by default and retain selection when adding multiple items",function(){testNode.innerHTML="<select data-bind=\"options: filterValues, optionsCaption: 'foo'\">";var e={filterValues:ko.observableArray()};ko.applyBindings(e,testNode),expect(testNode.childNodes[0]).toHaveSelectedValues([undefined]);var t=testNode.childNodes[0].options[0];e.filterValues.push("1"),e.filterValues.push("2"),expect(testNode.childNodes[0]).toHaveSelectedValues([undefined]),expect(testNode.childNodes[0].options[0]).toBe(t)}),it("Should trigger a change event when the options selection is populated or changed by modifying the options data (single select)",function(){var e=new ko.observableArray(["A","B","C"]),t=0;testNode.innerHTML="<select data-bind='options:myValues'></select>",ko.utils.registerEventHandler(testNode.childNodes[0],"change",function(){t++}),ko.applyBindings({myValues:e},testNode),expect(testNode.childNodes[0].selectedIndex).toEqual(0),expect(t).toEqual(1),e(["B","C","A"]),expect(testNode.childNodes[0].selectedIndex).toEqual(2),expect(t).toEqual(1),e(["D","E"]),expect(testNode.childNodes[0].selectedIndex).toEqual(0),expect(t).toEqual(2),e([]),expect(testNode.childNodes[0].selectedIndex).toEqual(-1),expect(t).toEqual(3),e([1,2,3]),expect(testNode.childNodes[0].selectedIndex).toEqual(0),expect(t).toEqual(4)}),it("Should trigger a change event when the options selection is changed by modifying the options data (multiple select)",function(){var e=new ko.observableArray(["A","B","C"]),t=0;testNode.innerHTML="<select data-bind='options:myValues' multiple='multiple'></select>",ko.utils.registerEventHandler(testNode.childNodes[0],"change",function(){t++}),ko.applyBindings({myValues:e},testNode),expect(t).toEqual(0),testNode.childNodes[0].options[0].selected=!0,expect(testNode.childNodes[0]).toHaveSelectedValues(["A"]),e(["B","C","A"]),expect(testNode.childNodes[0]).toHaveSelectedValues(["A"]),expect(t).toEqual(0),testNode.childNodes[0].options[0].selected=!0,expect(testNode.childNodes[0]).toHaveSelectedValues(["B","A"]),e(["C","A"]),expect(testNode.childNodes[0]).toHaveSelectedValues(["A"]),expect(t).toEqual(1),e(["D","E"]),expect(testNode.childNodes[0]).toHaveSelectedValues([]),expect(t).toEqual(2),e([]),expect(t).toEqual(2),e([ko.observable("X"),ko.observable("Y")]),expect(t).toEqual(2),testNode.childNodes[0].options[0].selected=testNode.childNodes[0].options[1].selected=!0,expect(testNode.childNodes[0]).toHaveSelectedValues(["X","Y"]),e()[1]("Z"),expect(testNode.childNodes[0]).toHaveSelectedValues(["X"]),expect(t).toEqual(3)}),it("Should place a caption at the top of the options list and display it when the model value is undefined",function(){testNode.innerHTML='<select data-bind=\'options:["A", "B"], optionsCaption: "Select one..."\'></select>',ko.applyBindings({},testNode),expect(testNode.childNodes[0]).toHaveTexts(["Select one...","A","B"])}),it("Should not include the caption if the options value is null",function(){testNode.innerHTML="<select data-bind='options: null, optionsCaption: \"Select one...\"'></select>",ko.applyBindings({},testNode),expect(testNode.childNodes[0]).toHaveTexts([])}),it("Should not include the caption if the optionsCaption value is null",function(){testNode.innerHTML='<select data-bind=\'options: ["A", "B"], optionsCaption: null\'></select>',ko.applyBindings({},testNode),expect(testNode.childNodes[0]).toHaveTexts(["A","B"])}),it("Should not include the caption if the optionsCaption value is undefined",function(){testNode.innerHTML='<select data-bind=\'options: ["A", "B"], optionsCaption: test\'></select>',ko.applyBindings({test:ko.observable()},testNode),expect(testNode.childNodes[0]).toHaveTexts(["A","B"])}),it("Should include a caption even if it's blank",function(){testNode.innerHTML='<select data-bind=\'options: ["A","B"], optionsCaption: ""\'></select>',ko.applyBindings({},testNode),expect(testNode.childNodes[0]).toHaveTexts(["","A","B"])}),it("Should allow the caption to be given by an observable, and update it when the model value changes (without affecting selection)",function(){var e=ko.observable("Initial caption");testNode.innerHTML='<select data-bind=\'options:["A", "B"], optionsCaption: myCaption\'></select>',ko.applyBindings({myCaption:e},testNode),testNode.childNodes[0].options[2].selected=!0,expect(testNode.childNodes[0].selectedIndex).toEqual(2),expect(testNode.childNodes[0]).toHaveTexts(["Initial caption","A","B"]),e("New caption"),expect(testNode.childNodes[0].selectedIndex).toEqual(2),expect(testNode.childNodes[0]).toHaveTexts(["New caption","A","B"]),e(null),expect(testNode.childNodes[0].selectedIndex).toEqual(1),expect(testNode.childNodes[0]).toHaveTexts(["A","B"])}),it("Should allow the option text to be given by an observable and update it when the model changes without affecting selection",function(){var e=[{name:ko.observable("Annie"),id:"A"},{name:ko.observable("Bert"),id:"B"}];testNode.innerHTML="<select data-bind=\"options: people, optionsText: 'name', optionsValue: 'id', optionsCaption: '-'\"></select>",ko.applyBindings({people:e},testNode),testNode.childNodes[0].options[2].selected=!0,expect(testNode.childNodes[0].selectedIndex).toEqual(2),expect(testNode.childNodes[0]).toHaveTexts(["-","Annie","Bert"]),e[1].name("Bob"),expect(testNode.childNodes[0].selectedIndex).toEqual(2),expect(testNode.childNodes[0]).toHaveTexts(["-","Annie","Bob"])}),it("Should call an optionsAfterRender callback function and not cause updates if an observable accessed in the callback is changed",function(){testNode.innerHTML="<select data-bind=\"options: someItems, optionsText: 'childprop', optionsAfterRender: callback\"></select>";var e=ko.observable(1),t=ko.observableArray([{childprop:"first child"}]),n=0;ko.applyBindings({someItems:t,callback:function(){e(),n++}},testNode),expect(n).toEqual(1),t().push({childprop:"hidden child"}),expect(testNode.childNodes[0]).toContainText("first child"),e(2),expect(testNode.childNodes[0]).toContainText("first child"),t.valueHasMutated(),expect(testNode.childNodes[0]).toContainText("first childhidden child"),expect(n).toEqual(2)}),it("Should ignore the optionsAfterRender binding if the callback was not provided or not a function",function(){testNode.innerHTML="<select data-bind=\"options: someItems, optionsText: 'childprop', optionsAfterRender: callback\"></select>";var e=ko.observableArray([{childprop:"first child"}]);ko.applyBindings({someItems:e,callback:null},testNode),expect(testNode.childNodes[0]).toContainText("first child")})})}.call(e),t})})(this);