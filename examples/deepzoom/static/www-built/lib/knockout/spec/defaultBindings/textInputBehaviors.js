(function(e){var t;define([],function(){return function(){describe("Binding: TextInput",function(){beforeEach(jasmine.prepareTestNode),it("Should assign the value to the node",function(){testNode.innerHTML="<input data-bind='textInput:123' />",ko.applyBindings(null,testNode),expect(testNode.childNodes[0].value).toEqual("123")}),it("Should treat null values as empty strings",function(){testNode.innerHTML="<input data-bind='textInput:myProp' />",ko.applyBindings({myProp:ko.observable(0)},testNode),expect(testNode.childNodes[0].value).toEqual("0")}),it("Should assign an empty string as value if the model value is null",function(){testNode.innerHTML="<input data-bind='textInput:(null)' />",ko.applyBindings(null,testNode),expect(testNode.childNodes[0].value).toEqual("")}),it("Should assign an empty string as value if the model value is undefined",function(){testNode.innerHTML="<input data-bind='textInput:undefined' />",ko.applyBindings(null,testNode),expect(testNode.childNodes[0].value).toEqual("")}),it("For observable values, should unwrap the value and update on change",function(){var e=new ko.observable(123);testNode.innerHTML="<input data-bind='textInput:someProp' />",ko.applyBindings({someProp:e},testNode),expect(testNode.childNodes[0].value).toEqual("123"),e(456),expect(testNode.childNodes[0].value).toEqual("456")}),it("For observable values, should update on change if new value is 'strictly' different from previous value",function(){var e=new ko.observable("+123");testNode.innerHTML="<input data-bind='textInput:someProp' />",ko.applyBindings({someProp:e},testNode),expect(testNode.childNodes[0].value).toEqual("+123"),e(123),expect(testNode.childNodes[0].value).toEqual("123")}),it("For writeable observable values, should catch the node's onchange and write values back to the observable",function(){var e=new ko.observable(123);testNode.innerHTML="<input data-bind='textInput:someProp' />",ko.applyBindings({someProp:e},testNode),testNode.childNodes[0].value="some user-entered value",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e()).toEqual("some user-entered value")}),it("For writeable observable values, when model rejects change, update view to match",function(){var e=ko.observable(123),t=ko.observable(!0),n=ko.computed({read:e,write:function(n){isNaN(n)?t(!1):(t(!0),e(n))}});testNode.innerHTML="<input data-bind='textInput: valueForEditing' />",ko.applyBindings({valueForEditing:n},testNode),testNode.childNodes[0].value="1234",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e()).toEqual("1234"),expect(t()).toEqual(!0),expect(testNode.childNodes[0].value).toEqual("1234"),testNode.childNodes[0].value="1234a",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e()).toEqual("1234"),expect(t()).toEqual(!1),expect(testNode.childNodes[0].value).toEqual("1234a"),testNode.childNodes[0].value="1234",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e()).toEqual("1234"),expect(t()).toEqual(!0),expect(testNode.childNodes[0].value).toEqual("1234")}),it("Should ignore node changes when bound to a read-only observable",function(){var e=ko.computed(function(){return"zzz"}),t={prop:e};testNode.innerHTML="<input data-bind='textInput: prop' />",ko.applyBindings(t,testNode),expect(testNode.childNodes[0].value).toEqual("zzz"),testNode.childNodes[0].value="yyy",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(t.prop).toEqual(e),expect(e()).toEqual("zzz")}),it("For non-observable property values, should catch the node's onchange and write values back to the property",function(){var e={modelProperty123:456};testNode.innerHTML="<input data-bind='textInput: modelProperty123' />",ko.applyBindings(e,testNode),expect(testNode.childNodes[0].value).toEqual("456"),testNode.childNodes[0].value=789,ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e.modelProperty123).toEqual("789")}),it('Should support alias "textinput"',function(){testNode.innerHTML="<input data-bind='textinput:123' />",ko.applyBindings(null,testNode),expect(testNode.childNodes[0].value).toEqual("123")}),it('Should write to non-observable property values using "textinput" alias',function(){var e={modelProperty123:456};testNode.innerHTML="<input data-bind='textinput: modelProperty123' />",ko.applyBindings(e,testNode),expect(testNode.childNodes[0].value).toEqual("456"),testNode.childNodes[0].value=789,ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e.modelProperty123).toEqual("789")}),it("Should be able to read and write to a property of an object returned by a function",function(){var e={set:666},t={getSetter:function(){return e}};testNode.innerHTML="<input data-bind='textInput: getSetter().set' /><input data-bind='textInput: getSetter()[\"set\"]' /><input data-bind=\"textInput: getSetter()['set']\" />",ko.applyBindings(t,testNode),expect(testNode.childNodes[0].value).toEqual("666"),expect(testNode.childNodes[1].value).toEqual("666"),expect(testNode.childNodes[2].value).toEqual("666"),testNode.childNodes[0].value=667,ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e.set).toEqual("667"),testNode.childNodes[1].value=668,ko.utils.triggerEvent(testNode.childNodes[1],"change"),expect(e.set).toEqual("668"),testNode.childNodes[0].value=669,ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e.set).toEqual("669")}),it("Should be able to write to observable subproperties of an observable, even after the parent observable has changed",function(){var e=ko.observable("original value"),t=ko.observable(),n={myprop:ko.observable({subproperty:e})};testNode.innerHTML="<input data-bind='textInput: myprop().subproperty' />",ko.applyBindings(n,testNode),expect(testNode.childNodes[0].value).toEqual("original value"),n.myprop({subproperty:t}),testNode.childNodes[0].value="Some new value",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(t()).toEqual("Some new value"),expect(e()).toEqual("original value")}),it("Should update observable on input event (on supported browsers) or propertychange event (on old IE)",function(){var e=new ko.observable(123);testNode.innerHTML="<input data-bind='textInput: someProp' />",ko.applyBindings({someProp:e},testNode),expect(testNode.childNodes[0].value).toEqual("123"),testNode.childNodes[0].value="some user-entered value",(!jasmine.ieVersion||jasmine.ieVersion>=9)&&ko.utils.triggerEvent(testNode.childNodes[0],"input"),expect(e()).toEqual("some user-entered value")}),it("Should write only changed values to observable",function(){var e={writtenValue:""};testNode.innerHTML="<input data-bind='textInput: writtenValue' />",ko.applyBindings(e,testNode),testNode.childNodes[0].value="1234",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e.writtenValue).toEqual("1234"),e.writtenValue=undefined,ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e.writtenValue).toBeUndefined()}),typeof DEBUG!="undefined"&&DEBUG&&describe("Event processing",function(){beforeEach(function(){this.restoreAfter(ko.bindingHandlers.textInput,"_forceUpdateOn"),ko.bindingHandlers.textInput._forceUpdateOn=["afterkeydown"],jasmine.Clock.useMock()}),it("Should update observable asynchronously",function(){var e=new ko.observable("123");testNode.innerHTML="<input data-bind='textInput:someProp' />",ko.applyBindings({someProp:e},testNode),ko.utils.triggerEvent(testNode.childNodes[0],"keydown"),testNode.childNodes[0].value="some user-entered value",expect(e()).toEqual("123"),jasmine.Clock.tick(20),expect(e()).toEqual("some user-entered value")}),it('Should ignore "unchanged" notifications from observable during delayed event processing',function(){var e=new ko.observable("123");testNode.innerHTML="<input data-bind='textInput:someProp' />",ko.applyBindings({someProp:e},testNode),ko.utils.triggerEvent(testNode.childNodes[0],"keydown"),testNode.childNodes[0].value="some user-entered value",e.valueHasMutated(),expect(testNode.childNodes[0].value).toEqual("some user-entered value"),jasmine.Clock.tick(20),expect(e()).toEqual("some user-entered value")}),it("Should not ignore actual change notifications from observable during delayed event processing",function(){var e=new ko.observable("123");testNode.innerHTML="<input data-bind='textInput:someProp' />",ko.applyBindings({someProp:e},testNode),ko.utils.triggerEvent(testNode.childNodes[0],"keydown"),testNode.childNodes[0].value="some user-entered value",e("some value from the server"),expect(testNode.childNodes[0].value).toEqual("some value from the server"),jasmine.Clock.tick(20),expect(e()).toEqual("some value from the server")}),it("Should update model property using earliest available event",function(){var e={someProp:"123"};testNode.innerHTML="<input data-bind='textInput:someProp' />",ko.applyBindings(e,testNode),ko.utils.triggerEvent(testNode.childNodes[0],"keydown"),testNode.childNodes[0].value="some user-entered value",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e.someProp).toEqual("some user-entered value"),expect(testNode.childNodes[0]._ko_textInputProcessedEvent).toEqual("change"),e.someProp=undefined,jasmine.Clock.tick(20),expect(e.someProp).toBeUndefined(),expect(testNode.childNodes[0]._ko_textInputProcessedEvent).toEqual("change")})})})}.call(e),t})})(this);