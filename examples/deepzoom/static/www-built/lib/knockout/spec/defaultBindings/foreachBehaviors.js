(function(e){var t;define([],function(){return function(){describe("Binding: Foreach",function(){beforeEach(jasmine.prepareTestNode),it("Should remove descendant nodes from the document (and not bind them) if the value is falsey",function(){testNode.innerHTML="<div data-bind='foreach: someItem'><span data-bind='text: someItem.nonExistentChildProp'></span></div>",expect(testNode.childNodes[0].childNodes.length).toEqual(1),ko.applyBindings({someItem:null},testNode),expect(testNode.childNodes[0].childNodes.length).toEqual(0)}),it("Should remove descendant nodes from the document (and not bind them) if the value is undefined",function(){testNode.innerHTML="<div data-bind='foreach: someItem'><span data-bind='text: someItem.nonExistentChildProp'></span></div>",expect(testNode.childNodes[0].childNodes.length).toEqual(1),ko.applyBindings({someItem:undefined},testNode),expect(testNode.childNodes[0].childNodes.length).toEqual(0)}),it("Should duplicate descendant nodes for each value in the array value (and bind them in the context of that supplied value)",function(){testNode.innerHTML="<div data-bind='foreach: someItems'><span data-bind='text: childProp'></span></div>";var e=[{childProp:"first child"},{childProp:"second child"}];ko.applyBindings({someItems:e},testNode),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: childprop">first child</span><span data-bind="text: childprop">second child</span>')}),it("Should clean away any data values attached to the original template nodes before use",function(){testNode.innerHTML="<div data-bind='foreach: [1, 2]'><span></span></div>";var e=testNode.childNodes[0].childNodes[0];expect(e.tagName).toEqual("SPAN"),ko.utils.domData.set(e,"mydata",123),expect(ko.utils.domData.get(e,"mydata")).toEqual(123),ko.applyBindings(null,testNode),expect(ko.utils.domData.get(e,"mydata")).toEqual(undefined),expect(testNode.childNodes[0]).toContainHtml("<span></span><span></span>"),expect(ko.utils.domData.get(testNode.childNodes[0].childNodes[0],"mydata")).toEqual(undefined),expect(ko.utils.domData.get(testNode.childNodes[0].childNodes[1],"mydata")).toEqual(undefined)}),it("Should be able to use $data to reference each array item being bound",function(){testNode.innerHTML="<div data-bind='foreach: someItems'><span data-bind='text: $data'></span></div>";var e=["alpha","beta"];ko.applyBindings({someItems:e},testNode),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: $data">alpha</span><span data-bind="text: $data">beta</span>')}),it("Should add and remove nodes to match changes in the bound array",function(){testNode.innerHTML="<div data-bind='foreach: someItems'><span data-bind='text: childProp'></span></div>";var e=ko.observableArray([{childProp:"first child"},{childProp:"second child"}]);ko.applyBindings({someItems:e},testNode),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: childprop">first child</span><span data-bind="text: childprop">second child</span>'),e.unshift({childProp:"zeroth child"}),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: childprop">zeroth child</span><span data-bind="text: childprop">first child</span><span data-bind="text: childprop">second child</span>'),e.splice(2,0,{childProp:"middle child"}),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: childprop">zeroth child</span><span data-bind="text: childprop">first child</span><span data-bind="text: childprop">middle child</span><span data-bind="text: childprop">second child</span>'),e.push({childProp:"last child"}),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: childprop">zeroth child</span><span data-bind="text: childprop">first child</span><span data-bind="text: childprop">middle child</span><span data-bind="text: childprop">second child</span><span data-bind="text: childprop">last child</span>'),e.shift(),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: childprop">first child</span><span data-bind="text: childprop">middle child</span><span data-bind="text: childprop">second child</span><span data-bind="text: childprop">last child</span>'),e.splice(1,1),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: childprop">first child</span><span data-bind="text: childprop">second child</span><span data-bind="text: childprop">last child</span>'),e.pop(),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: childprop">first child</span><span data-bind="text: childprop">second child</span>'),e.destroy(e()[0]),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: childprop">second child</span>')}),it("Should remove all nodes corresponding to a removed array item, even if they were generated via containerless templates",function(){testNode.innerHTML="<div data-bind='foreach: someitems'>a<!-- ko if:true -->b<!-- /ko --></div>";var e=ko.observableArray([1,2]);ko.applyBindings({someitems:e},testNode),expect(testNode).toContainHtml('<div data-bind="foreach: someitems">a<!-- ko if:true -->b<!-- /ko -->a<!-- ko if:true -->b<!-- /ko --></div>'),e.splice(1,1),expect(testNode).toContainHtml('<div data-bind="foreach: someitems">a<!-- ko if:true -->b<!-- /ko --></div>')}),it("Should remove all nodes corresponding to a removed array item, even if they were added via containerless syntax and there are no other nodes",function(){ko.bindingHandlers.test={init:function(e,t){var n=t();ko.virtualElements.prepend(e,document.createTextNode(n))}},ko.virtualElements.allowedBindings.test=!0,testNode.innerHTML="x-<!--ko foreach: someitems--><!--ko test:$data--><!--/ko--><!--/ko-->";var e=ko.observableArray(["aaa","bbb"]);ko.applyBindings({someitems:e},testNode),expect(testNode).toContainText("x-aaabbb"),e.splice(1,1),expect(testNode).toContainText("x-aaa")}),it("Should update all nodes corresponding to a changed array item, even if they were generated via containerless templates",function(){testNode.innerHTML="<div data-bind='foreach: someitems'><!-- ko if:true --><span data-bind='text: $data'></span><!-- /ko --></div>";var e=[ko.observable("A"),ko.observable("B")];ko.applyBindings({someitems:e},testNode),expect(testNode).toContainText("AB"),e[0]("A2"),expect(testNode).toContainText("A2B")}),it('Should be able to supply show "_destroy"ed items via includeDestroyed option',function(){testNode.innerHTML="<div data-bind='foreach: { data: someItems, includeDestroyed: true }'><span data-bind='text: childProp'></span></div>";var e=ko.observableArray([{childProp:"first child"},{childProp:"second child",_destroy:!0}]);ko.applyBindings({someItems:e},testNode),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: childprop">first child</span><span data-bind="text: childprop">second child</span>')}),it("Should be able to supply afterAdd and beforeRemove callbacks",function(){testNode.innerHTML="<div data-bind='foreach: { data: someItems, afterAdd: myAfterAdd, beforeRemove: myBeforeRemove }'><span data-bind='text: childprop'></span></div>";var e=ko.observableArray([{childprop:"first child"}]),t=[],n=[];ko.applyBindings({someItems:e,myAfterAdd:function(e,n,r){t.push({elem:e,index:n,value:r,currentParentClone:e.parentNode.cloneNode(!0)})},myBeforeRemove:function(e,t,r){n.push({elem:e,index:t,value:r,currentParentClone:e.parentNode.cloneNode(!0)})}},testNode),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: childprop">first child</span>'),e.push({childprop:"added child"}),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: childprop">first child</span><span data-bind="text: childprop">added child</span>'),expect(t.length).toEqual(1),expect(t[0].elem).toEqual(testNode.childNodes[0].childNodes[1]),expect(t[0].index).toEqual(1),expect(t[0].value.childprop).toEqual("added child"),expect(t[0].currentParentClone).toContainHtml('<span data-bind="text: childprop">first child</span><span data-bind="text: childprop">added child</span>'),e.shift(),expect(n.length).toEqual(1),expect(n[0].elem).toContainText("first child"),expect(n[0].index).toEqual(0),expect(n[0].value.childprop).toEqual("first child"),expect(n[0].currentParentClone).toContainHtml('<span data-bind="text: childprop">first child</span><span data-bind="text: childprop">added child</span>'),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: childprop">first child</span><span data-bind="text: childprop">added child</span>')}),it("Should call an afterRender callback function and not cause updates if an observable accessed in the callback is changed",function(){testNode.innerHTML="<div data-bind='foreach: { data: someItems, afterRender: callback }'><span data-bind='text: childprop'></span></div>";var e=ko.observable(1),t=ko.observableArray([{childprop:"first child"}]),n=0;ko.applyBindings({someItems:t,callback:function(){e(),n++}},testNode),expect(n).toEqual(1),t().push({childprop:"hidden child"}),expect(testNode.childNodes[0]).toContainText("first child"),e(2),expect(testNode.childNodes[0]).toContainText("first child"),t.valueHasMutated(),expect(testNode.childNodes[0]).toContainText("first childhidden child")}),it("Should call an afterRender callback, passing all of the rendered nodes, accounting for node preprocessing and virtual element bindings",function(){var e=ko.bindingProvider.instance,t=function(){};t.prototype=e,ko.bindingProvider.instance=new t,ko.bindingProvider.instance.preprocessNode=function(e){if(e.nodeType===3&&e.data.charAt(0)==="$"){var t=[document.createComment("ko text: "+e.data),document.createComment("/ko")];for(var n=0;n<t.length;n++)e.parentNode.insertBefore(t[n],e);return e.parentNode.removeChild(e),t}},testNode.innerHTML="<div data-bind='foreach: { data: someItems, afterRender: callback }'><span>[</span>$data<span>]</span></div>";var n=ko.observableArray(["Alpha","Beta"]),r=[];ko.applyBindings({someItems:n,callback:function(e,t){expect(e.length).toBe(5),expect(e[0]).toContainText("["),expect(e[1].nodeType).toBe(8),expect(e[2].nodeType).toBe(3),expect(e[3].nodeType).toBe(8),expect(e[4]).toContainText("]"),r.push(t)}},testNode),expect(testNode.childNodes[0]).toContainText("[Alpha][Beta]"),expect(r).toEqual(["Alpha","Beta"]),ko.bindingProvider.instance=e}),it("Should call an afterAdd callback function and not cause updates if an observable accessed in the callback is changed",function(){testNode.innerHTML="<div data-bind='foreach: { data: someItems, afterAdd: callback }'><span data-bind='text: childprop'></span></div>";var e=ko.observable(1),t=ko.observableArray([]),n=0;ko.applyBindings({someItems:t,callback:function(){e(),n++}},testNode),t.push({childprop:"added child"}),expect(n).toEqual(1),t().push({childprop:"hidden child"}),expect(testNode.childNodes[0]).toContainText("added child"),e(2),expect(testNode.childNodes[0]).toContainText("added child"),t.valueHasMutated(),expect(testNode.childNodes[0]).toContainText("added childhidden child")}),it("Should call an beforeRemove callback function and not cause updates if an observable accessed in the callback is changed",function(){testNode.innerHTML="<div data-bind='foreach: { data: someItems, beforeRemove: callback }'><span data-bind='text: childprop'></span></div>";var e=ko.observable(1),t=ko.observableArray([{childprop:"first child"},{childprop:"second child"}]),n=0;ko.applyBindings({someItems:t,callback:function(t){e(),n++,ko.removeNode(t)}},testNode),t.pop(),expect(n).toEqual(1),t().push({childprop:"hidden child"}),expect(testNode.childNodes[0]).toContainText("first child"),e(2),expect(testNode.childNodes[0]).toContainText("first child"),t.valueHasMutated(),expect(testNode.childNodes[0]).toContainText("first childhidden child")}),it("Should call an afterMove callback function and not cause updates if an observable accessed in the callback is changed",function(){testNode.innerHTML="<div data-bind='foreach: { data: someItems, afterMove: callback }'><span data-bind='text: childprop'></span></div>";var e=ko.observable(1),t=ko.observableArray([{childprop:"first child"}]),n=0;ko.applyBindings({someItems:t,callback:function(){e(),n++}},testNode),t.splice(0,0,{childprop:"added child"}),expect(n).toEqual(1),t().push({childprop:"hidden child"}),expect(testNode.childNodes[0]).toContainText("added childfirst child"),e(2),expect(testNode.childNodes[0]).toContainText("added childfirst child"),t.valueHasMutated(),expect(testNode.childNodes[0]).toContainText("added childfirst childhidden child")}),it("Should call an beforeMove callback function and not cause updates if an observable accessed in the callback is changed",function(){testNode.innerHTML="<div data-bind='foreach: { data: someItems, beforeMove: callback }'><span data-bind='text: childprop'></span></div>";var e=ko.observable(1),t=ko.observableArray([{childprop:"first child"}]),n=0;ko.applyBindings({someItems:t,callback:function(){e(),n++}},testNode),t.splice(0,0,{childprop:"added child"}),expect(n).toEqual(1),t().push({childprop:"hidden child"}),expect(testNode.childNodes[0]).toContainText("added childfirst child"),e(2),expect(testNode.childNodes[0]).toContainText("added childfirst child"),t.valueHasMutated(),expect(testNode.childNodes[0]).toContainText("added childfirst childhidden child")}),it("Should not double-unwrap the given value",function(){testNode.innerHTML="<div data-bind='foreach: myArray'><span data-bind='text: $data'></span></div>";var e=ko.observable(ko.observableArray(["data value"]));ko.applyBindings({myArray:e},testNode),expect(testNode.childNodes[0]).toContainText("")}),it("Should be able to nest foreaches and access binding contexts both during and after binding",function(){testNode.innerHTML="<div data-bind='foreach: items'><div data-bind='foreach: children'>(Val: <span data-bind='text: $data'></span>, Parents: <span data-bind='text: $parents.length'></span>, Rootval: <span data-bind='text: $root.rootVal'></span>)</div></div>";var e={rootVal:"ROOTVAL",items:ko.observableArray([{children:ko.observableArray(["A1","A2","A3"])},{children:ko.observableArray(["B1","B2"])}])};ko.applyBindings(e,testNode),expect(testNode.childNodes[0].childNodes[0]).toContainText("(Val: A1, Parents: 2, Rootval: ROOTVAL)(Val: A2, Parents: 2, Rootval: ROOTVAL)(Val: A3, Parents: 2, Rootval: ROOTVAL)"),expect(testNode.childNodes[0].childNodes[1]).toContainText("(Val: B1, Parents: 2, Rootval: ROOTVAL)(Val: B2, Parents: 2, Rootval: ROOTVAL)");var t=testNode.childNodes[0].childNodes[0].childNodes[1];expect(t.nodeType).toEqual(1),expect(ko.dataFor(t)).toEqual("A1"),expect(ko.contextFor(t).$parent.children()[2]).toEqual("A3"),expect(ko.contextFor(t).$parents[1].items()[1].children()[1]).toEqual("B2"),expect(ko.contextFor(t).$root.rootVal).toEqual("ROOTVAL")}),it("Should be able to define a 'foreach' region using a containerless template",function(){testNode.innerHTML="hi <!-- ko foreach: someitems --><span data-bind='text: childprop'></span><!-- /ko -->";var e=[{childprop:"first child"},{childprop:"second child"}];ko.applyBindings({someitems:e},testNode),expect(testNode).toContainHtml('hi <!-- ko foreach: someitems --><span data-bind="text: childprop">first child</span><span data-bind="text: childprop">second child</span><!-- /ko -->'),expect(ko.dataFor(testNode.childNodes[3]).childprop).toEqual("second child"),expect(ko.contextFor(testNode.childNodes[3]).$parent.someitems.length).toEqual(2)}),it("Should be able to nest 'foreach' regions defined using containerless templates",function(){var e=document.createElement("DIV");testNode.innerHTML="",testNode.appendChild(document.createComment("ko foreach: items")),testNode.appendChild(document.createComment("ko foreach: children")),e.innerHTML="(Val: <span data-bind='text: $data'></span>, Parents: <span data-bind='text: $parents.length'></span>, Rootval: <span data-bind='text: $root.rootVal'></span>)";while(e.firstChild)testNode.appendChild(e.firstChild);testNode.appendChild(document.createComment("/ko")),testNode.appendChild(document.createComment("/ko"));var t={rootVal:"ROOTVAL",items:ko.observableArray([{children:ko.observableArray(["A1","A2","A3"])},{children:ko.observableArray(["B1","B2"])}])};ko.applyBindings(t,testNode),expect(testNode).toContainText("(Val: A1, Parents: 2, Rootval: ROOTVAL)(Val: A2, Parents: 2, Rootval: ROOTVAL)(Val: A3, Parents: 2, Rootval: ROOTVAL)(Val: B1, Parents: 2, Rootval: ROOTVAL)(Val: B2, Parents: 2, Rootval: ROOTVAL)");var n=testNode.childNodes[3];expect(n).toContainText("A1"),expect(ko.dataFor(n)).toEqual("A1"),expect(ko.contextFor(n).$parent.children()[2]).toEqual("A3"),expect(ko.contextFor(n).$parents[1].items()[1].children()[1]).toEqual("B2"),expect(ko.contextFor(n).$root.rootVal).toEqual("ROOTVAL")}),it("Should be able to nest 'if' inside 'foreach' defined using containerless templates",function(){testNode.innerHTML="<ul></ul>",testNode.childNodes[0].appendChild(document.createComment("ko foreach: items")),testNode.childNodes[0].appendChild(document.createElement("li")),testNode.childNodes[0].childNodes[1].innerHTML="<span data-bind='text: childval.childprop'></span>",testNode.childNodes[0].childNodes[1].insertBefore(document.createComment("ko if: childval"),testNode.childNodes[0].childNodes[1].firstChild),testNode.childNodes[0].childNodes[1].appendChild(document.createComment("/ko")),testNode.childNodes[0].appendChild(document.createComment("/ko"));var e={items:[{childval:{childprop:123}},{childval:null},{childval:{childprop:456}}]};ko.applyBindings(e,testNode),expect(testNode).toContainHtml('<ul><!--ko foreach: items--><li><!--ko if: childval--><span data-bind="text: childval.childprop">123</span><!--/ko--></li><li><!--ko if: childval--><!--/ko--></li><li><!--ko if: childval--><span data-bind="text: childval.childprop">456</span><!--/ko--></li><!--/ko--></ul>')}),it("Should be able to use containerless templates directly inside UL elements even when closing LI tags are omitted",function(){testNode.innerHTML="<ul><li>Header item<!-- ko foreach: someitems --><li data-bind='text: $data'><!-- /ko --></ul>";var e={someitems:["Alpha","Beta"]};ko.applyBindings(e,testNode);var t=testNode.innerHTML.toLowerCase().match(/<\/li>/g);t?t.length==3?expect(testNode).toContainHtml('<ul><li>header item</li><!-- ko foreach: someitems --><li data-bind="text: $data">alpha</li><li data-bind="text: $data">beta</li><!-- /ko --></ul>'):expect(testNode).toContainHtml('<ul><li>header item</li><!-- ko foreach: someitems --><li data-bind="text: $data">alpha<li data-bind="text: $data">beta</li><!-- /ko --></ul>'):expect(testNode).toContainHtml('<ul><li>header item<!-- ko foreach: someitems --><li data-bind="text: $data">alpha<li data-bind="text: $data">beta<!-- /ko --></ul>')}),it("Should be able to nest containerless templates directly inside UL elements, even on IE < 8 with its bizarre HTML parsing/formatting",function(){testNode.innerHTML="",testNode.appendChild(document.createElement("ul")),testNode.firstChild.appendChild(document.createComment("ko foreach: ['A', 'B']")),testNode.firstChild.appendChild(document.createComment("ko if: $data == 'B'")),testNode.firstChild.appendChild(document.createElement("li")),testNode.firstChild.lastChild.setAttribute("data-bind","text: $data"),testNode.firstChild.lastChild.appendChild(document.createComment("/ko")),testNode.firstChild.lastChild.appendChild(document.createComment("/ko")),ko.applyBindings(null,testNode),expect(testNode).toContainText("B")}),it('Should be able to give an alias to $data using "as"',function(){testNode.innerHTML="<div data-bind='foreach: { data: someItems, as: \"item\" }'><span data-bind='text: item'></span></div>";var e=["alpha","beta"];ko.applyBindings({someItems:e},testNode),expect(testNode.childNodes[0]).toContainHtml('<span data-bind="text: item">alpha</span><span data-bind="text: item">beta</span>')}),it('Should be able to give an alias to $data using "as", and use it within a nested loop',function(){testNode.innerHTML="<div data-bind='foreach: { data: someItems, as: \"item\" }'><span data-bind='foreach: sub'><span data-bind='text: item.name+\":\"+$data'></span>,</span></div>";var e=[{name:"alpha",sub:["a","b"]},{name:"beta",sub:["c"]}];ko.applyBindings({someItems:e},testNode),expect(testNode.childNodes[0]).toContainText("alpha:a,alpha:b,beta:c,")}),it('Should be able to set up multiple nested levels of aliases using "as"',function(){testNode.innerHTML="<div data-bind='foreach: { data: someItems, as: \"item\" }'><span data-bind='foreach: { data: sub, as: \"subvalue\" }'><span data-bind='text: item.name+\":\"+subvalue'></span>,</span></div>";var e=[{name:"alpha",sub:["a","b"]},{name:"beta",sub:["c","d"]}];ko.applyBindings({someItems:e},testNode),expect(testNode.childNodes[0]).toContainText("alpha:a,alpha:b,beta:c,beta:d,")}),it('Should be able to give an alias to $data using "as", and use it within arbitrary descendant binding contexts',function(){testNode.innerHTML="<div data-bind='foreach: { data: someItems, as: \"item\" }'><span data-bind='if: item.length'><span data-bind='text: item'></span>,</span></div>";var e=["alpha","beta"];ko.applyBindings({someItems:e},testNode),expect(testNode.childNodes[0]).toContainText("alpha,beta,")}),it('Should be able to give an alias to $data using "as", and use it within descendant binding contexts defined using containerless syntax',function(){testNode.innerHTML="<div data-bind='foreach: { data: someItems, as: \"item\" }'>x<!-- ko if: item.length --><span data-bind='text: item'></span>x,<!-- /ko --></div>";var e=["alpha","beta"];ko.applyBindings({someItems:e},testNode),expect(testNode.childNodes[0]).toContainText("xalphax,xbetax,")}),it("Should be able to output HTML5 elements (even on IE<9, as long as you reference either innershiv.js or jQuery1.7+Modernizr)",function(){ko.utils.setHtml(testNode,"<div data-bind='foreach:someitems'><section data-bind='text: $data'></section></div>");var e={someitems:["Alpha","Beta"]};ko.applyBindings(e,testNode),expect(testNode).toContainHtml('<div data-bind="foreach:someitems"><section data-bind="text: $data">alpha</section><section data-bind="text: $data">beta</section></div>')}),it("Should be able to output HTML5 elements within container-less templates (same as above)",function(){ko.utils.setHtml(testNode,"xxx<!-- ko foreach:someitems --><div><section data-bind='text: $data'></section></div><!-- /ko -->");var e={someitems:["Alpha","Beta"]};ko.applyBindings(e,testNode),expect(testNode).toContainHtml('xxx<!-- ko foreach:someitems --><div><section data-bind="text: $data">alpha</section></div><div><section data-bind="text: $data">beta</section></div><!-- /ko -->')}),it("Should provide access to observable array items through $rawData",function(){testNode.innerHTML="<div data-bind='foreach: someItems'><input data-bind='value: $rawData'/></div>";var e=ko.observable("first"),t=ko.observable("second"),n=ko.observableArray([e,t]);ko.applyBindings({someItems:n},testNode),expect(testNode.childNodes[0]).toHaveValues(["first","second"]),testNode.childNodes[0].childNodes[0].value="third",ko.utils.triggerEvent(testNode.childNodes[0].childNodes[0],"change"),expect(e()).toEqual("third"),t("fourth"),expect(testNode.childNodes[0]).toHaveValues(["third","fourth"]),n([e]),expect(testNode.childNodes[0]).toHaveValues(["third"])}),it("Should not re-render the nodes when a observable array item changes",function(){testNode.innerHTML="<div data-bind='foreach: someItems'><span data-bind='text: $data'></span></div>";var e=ko.observable("first"),t=[e];ko.applyBindings({someItems:t},testNode),expect(testNode.childNodes[0]).toContainText("first");var n=testNode.childNodes[0].childNodes[0];e("second"),expect(testNode.childNodes[0]).toContainText("second"),expect(testNode.childNodes[0].childNodes[0]).toEqual(n)})})}.call(e),t})})(this);