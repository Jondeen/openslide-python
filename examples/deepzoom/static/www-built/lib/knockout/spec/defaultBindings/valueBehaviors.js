(function(e){var t;define([],function(){return function(){describe("Binding: Value",function(){beforeEach(jasmine.prepareTestNode),it("Should assign the value to the node",function(){testNode.innerHTML="<input data-bind='value:123' />",ko.applyBindings(null,testNode),expect(testNode.childNodes[0].value).toEqual("123")}),it("Should treat null values as empty strings",function(){testNode.innerHTML="<input data-bind='value:myProp' />",ko.applyBindings({myProp:ko.observable(0)},testNode),expect(testNode.childNodes[0].value).toEqual("0")}),it("Should assign an empty string as value if the model value is null",function(){testNode.innerHTML="<input data-bind='value:(null)' />",ko.applyBindings(null,testNode),expect(testNode.childNodes[0].value).toEqual("")}),it("Should assign an empty string as value if the model value is undefined",function(){testNode.innerHTML="<input data-bind='value:undefined' />",ko.applyBindings(null,testNode),expect(testNode.childNodes[0].value).toEqual("")}),it("For observable values, should unwrap the value and update on change",function(){var e=new ko.observable(123);testNode.innerHTML="<input data-bind='value:someProp' />",ko.applyBindings({someProp:e},testNode),expect(testNode.childNodes[0].value).toEqual("123"),e(456),expect(testNode.childNodes[0].value).toEqual("456")}),it("For observable values, should update on change if new value is 'strictly' different from previous value",function(){var e=new ko.observable("+123");testNode.innerHTML="<input data-bind='value:someProp' />",ko.applyBindings({someProp:e},testNode),expect(testNode.childNodes[0].value).toEqual("+123"),e(123),expect(testNode.childNodes[0].value).toEqual("123")}),it("For writeable observable values, should catch the node's onchange and write values back to the observable",function(){var e=new ko.observable(123);testNode.innerHTML="<input data-bind='value:someProp' />",ko.applyBindings({someProp:e},testNode),testNode.childNodes[0].value="some user-entered value",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e()).toEqual("some user-entered value")}),it("For writeable observable values, should always write when triggered, even when value is the same",function(){var e=ko.observable(123),t=ko.observable(!0),n=ko.computed({read:e,write:function(n){isNaN(n)?t(!1):(t(!0),e(n))}});testNode.innerHTML="<input data-bind='value: valueForEditing' />",ko.applyBindings({valueForEditing:n},testNode),testNode.childNodes[0].value="1234",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e()).toEqual("1234"),expect(t()).toEqual(!0),testNode.childNodes[0].value="1234a",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e()).toEqual("1234"),expect(t()).toEqual(!1),testNode.childNodes[0].value="1234",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e()).toEqual("1234"),expect(t()).toEqual(!0)}),it("Should ignore node changes when bound to a read-only observable",function(){var e=ko.computed(function(){return"zzz"}),t={prop:e};testNode.innerHTML="<input data-bind='value: prop' />",ko.applyBindings(t,testNode),expect(testNode.childNodes[0].value).toEqual("zzz"),testNode.childNodes[0].value="yyy",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(t.prop).toEqual(e),expect(e()).toEqual("zzz")}),it("For non-observable property values, should catch the node's onchange and write values back to the property",function(){var e={modelProperty123:456};testNode.innerHTML="<input data-bind='value: modelProperty123' />",ko.applyBindings(e,testNode),expect(testNode.childNodes[0].value).toEqual("456"),testNode.childNodes[0].value=789,ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e.modelProperty123).toEqual("789")}),it("Should be able to read and write to a property of an object returned by a function",function(){var e={set:666},t={getSetter:function(){return e}};testNode.innerHTML="<input data-bind='value: getSetter().set' /><input data-bind='value: getSetter()[\"set\"]' /><input data-bind=\"value: getSetter()['set']\" />",ko.applyBindings(t,testNode),expect(testNode.childNodes[0].value).toEqual("666"),expect(testNode.childNodes[1].value).toEqual("666"),expect(testNode.childNodes[2].value).toEqual("666"),testNode.childNodes[0].value=667,ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e.set).toEqual("667"),testNode.childNodes[1].value=668,ko.utils.triggerEvent(testNode.childNodes[1],"change"),expect(e.set).toEqual("668"),testNode.childNodes[0].value=669,ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e.set).toEqual("669")}),it("Should be able to write to observable subproperties of an observable, even after the parent observable has changed",function(){var e=ko.observable("original value"),t=ko.observable(),n={myprop:ko.observable({subproperty:e})};testNode.innerHTML="<input data-bind='value: myprop().subproperty' />",ko.applyBindings(n,testNode),expect(testNode.childNodes[0].value).toEqual("original value"),n.myprop({subproperty:t}),testNode.childNodes[0].value="Some new value",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(t()).toEqual("Some new value"),expect(e()).toEqual("original value")}),it("Should only register one single onchange handler",function(){var e=[],t=new ko.observable(123);t.subscribe(function(t){e.push(t)}),expect(e.length).toEqual(0),testNode.innerHTML="<input data-bind='value:someProp' />",ko.applyBindings({someProp:t},testNode),testNode.childNodes[0].value="ABC",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e.length).toEqual(1),testNode.childNodes[0].value="DEF",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e.length).toEqual(2)}),it("Should be able to catch updates after specific events (e.g., keyup) instead of onchange",function(){var e=new ko.observable(123);testNode.innerHTML="<input data-bind='value:someProp, valueUpdate: \"keyup\"' />",ko.applyBindings({someProp:e},testNode),testNode.childNodes[0].value="some user-entered value",ko.utils.triggerEvent(testNode.childNodes[0],"keyup"),expect(e()).toEqual("some user-entered value")}),it("Should catch updates on change as well as the nominated valueUpdate event",function(){var e=new ko.observable(123);testNode.innerHTML="<input data-bind='value:someProp, valueUpdate: \"keyup\"' />",ko.applyBindings({someProp:e},testNode),testNode.childNodes[0].value="some user-entered value",ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(e()).toEqual("some user-entered value")}),it('Should delay reading value and updating observable when prefixing an event with "after"',function(){jasmine.Clock.useMock();var e=new ko.observable("123");testNode.innerHTML="<input data-bind='value:someProp, valueUpdate: \"afterkeyup\"' />",ko.applyBindings({someProp:e},testNode),ko.utils.triggerEvent(testNode.childNodes[0],"keyup"),testNode.childNodes[0].value="some user-entered value",expect(e()).toEqual("123"),jasmine.Clock.tick(20),expect(e()).toEqual("some user-entered value")}),it('Should ignore "unchanged" notifications from observable during delayed event processing',function(){jasmine.Clock.useMock();var e=new ko.observable("123");testNode.innerHTML="<input data-bind='value:someProp, valueUpdate: \"afterkeyup\"' />",ko.applyBindings({someProp:e},testNode),ko.utils.triggerEvent(testNode.childNodes[0],"keyup"),testNode.childNodes[0].value="some user-entered value",e.valueHasMutated(),expect(testNode.childNodes[0].value).toEqual("some user-entered value"),jasmine.Clock.tick(20),expect(e()).toEqual("some user-entered value")}),it("Should not ignore actual change notifications from observable during delayed event processing",function(){jasmine.Clock.useMock();var e=new ko.observable("123");testNode.innerHTML="<input data-bind='value:someProp, valueUpdate: \"afterkeyup\"' />",ko.applyBindings({someProp:e},testNode),ko.utils.triggerEvent(testNode.childNodes[0],"keyup"),testNode.childNodes[0].value="some user-entered value",e("some value from the server"),expect(testNode.childNodes[0].value).toEqual("some value from the server"),jasmine.Clock.tick(20),expect(e()).toEqual("some value from the server")}),it('On IE < 10, should handle autofill selection by treating "propertychange" followed by "blur" as a change event',function(){var e=jasmine.ieVersion&&jasmine.ieVersion<10;if(e){var t=(new ko.observable(123)).extend({notify:"always"}),n=0;t.subscribe(function(){n++}),testNode.innerHTML="<input data-bind='value:someProp' />",ko.applyBindings({someProp:t},testNode),ko.utils.triggerEvent(testNode.childNodes[0],"focus"),ko.utils.triggerEvent(testNode.childNodes[0],"blur"),expect(n).toEqual(0),testNode.childNodes[0].value="some user-entered value",ko.utils.triggerEvent(testNode.childNodes[0],"propertychange"),ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(t()).toEqual("some user-entered value"),expect(n).toEqual(1),ko.utils.triggerEvent(testNode.childNodes[0],"blur"),expect(n).toEqual(1),testNode.childNodes[0].value="different user-entered value",ko.utils.triggerEvent(testNode.childNodes[0],"propertychange"),ko.utils.triggerEvent(testNode.childNodes[0],"blur"),expect(t()).toEqual("different user-entered value"),expect(n).toEqual(2),ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(n).toEqual(3)}}),describe("For select boxes",function(){it("Should update selectedIndex when the model changes (options specified before value)",function(){var e=new ko.observable("B");testNode.innerHTML='<select data-bind=\'options:["A", "B"], value:myObservable\'></select>',ko.applyBindings({myObservable:e},testNode),expect(testNode.childNodes[0].selectedIndex).toEqual(1),expect(e()).toEqual("B"),e("A"),expect(testNode.childNodes[0].selectedIndex).toEqual(0),expect(e()).toEqual("A")}),it("Should update selectedIndex when the model changes (value specified before options)",function(){var e=new ko.observable("B");testNode.innerHTML='<select data-bind=\'value:myObservable, options:["A", "B"]\'></select>',ko.applyBindings({myObservable:e},testNode),expect(testNode.childNodes[0].selectedIndex).toEqual(1),expect(e()).toEqual("B"),e("A"),expect(testNode.childNodes[0].selectedIndex).toEqual(0),expect(e()).toEqual("A")}),it("Should display the caption when the model value changes to undefined, null, or \"\" when using 'options' binding",function(){var e=new ko.observable("B");testNode.innerHTML='<select data-bind=\'options:["A", "B"], optionsCaption:"Select...", value:myObservable\'></select>',ko.applyBindings({myObservable:e},testNode),expect(testNode.childNodes[0].selectedIndex).toEqual(2),e(undefined),expect(testNode.childNodes[0].selectedIndex).toEqual(0),e("B"),expect(testNode.childNodes[0].selectedIndex).toEqual(2),e(null),expect(testNode.childNodes[0].selectedIndex).toEqual(0),e("B"),expect(testNode.childNodes[0].selectedIndex).toEqual(2),e(""),expect(testNode.childNodes[0].selectedIndex).toEqual(0)}),it('Should display the caption when the model value changes to undefined, null, or "" when options specified directly',function(){var e=new ko.observable("B");testNode.innerHTML="<select data-bind='value:myObservable'><option value=''>Select...</option><option>A</option><option>B</option></select>",ko.applyBindings({myObservable:e},testNode),expect(testNode.childNodes[0].selectedIndex).toEqual(2),e(undefined),expect(testNode.childNodes[0].selectedIndex).toEqual(0),e("B"),expect(testNode.childNodes[0].selectedIndex).toEqual(2),e(null),expect(testNode.childNodes[0].selectedIndex).toEqual(0),e("B"),expect(testNode.childNodes[0].selectedIndex).toEqual(2),e(""),expect(testNode.childNodes[0].selectedIndex).toEqual(0)}),it('When size > 1, should unselect all options when value is undefined, null, or ""',function(){var e=new ko.observable("B");testNode.innerHTML="<select size='2' data-bind='options:[\"A\", \"B\"], value:myObservable'></select>",ko.applyBindings({myObservable:e},testNode),expect(testNode.childNodes[0].selectedIndex).toEqual(1),e(undefined),expect(testNode.childNodes[0].selectedIndex).toEqual(-1),e("B"),expect(testNode.childNodes[0].selectedIndex).toEqual(1),e(null),expect(testNode.childNodes[0].selectedIndex).toEqual(-1),e("B"),expect(testNode.childNodes[0].selectedIndex).toEqual(1),e(""),expect(testNode.childNodes[0].selectedIndex).toEqual(-1)}),it("Should update the model value when the UI is changed (setting it to undefined when the caption is selected)",function(){var e=new ko.observable("B");testNode.innerHTML='<select data-bind=\'options:["A", "B"], optionsCaption:"Select...", value:myObservable\'></select>',ko.applyBindings({myObservable:e},testNode);var t=testNode.childNodes[0];t.selectedIndex=1,ko.utils.triggerEvent(t,"change"),expect(e()).toEqual("A"),t.selectedIndex=0,ko.utils.triggerEvent(t,"change"),expect(e()).toEqual(undefined)}),it("Should be able to associate option values with arbitrary objects (not just strings)",function(){var e={},t={},n=ko.observable(t);testNode.innerHTML="<select data-bind='options: myOptions, value: selectedValue'></select>";var r=testNode.childNodes[0];ko.applyBindings({myOptions:[e,t],selectedValue:n},testNode),expect(r.selectedIndex).toEqual(1),n(e),expect(r.selectedIndex).toEqual(0),r.selectedIndex=1,ko.utils.triggerEvent(r,"change"),expect(n()).toEqual(t)}),it("Should automatically initialize the model property to match the first option value if no option value matches the current model property value",function(){var e=new ko.observable;testNode.innerHTML='<select data-bind=\'options:["A", "B"], value:myObservable\'></select>',ko.applyBindings({myObservable:e},testNode),expect(e()).toEqual("A"),ko.utils.domData.clear(testNode),testNode.innerHTML='<select data-bind=\'value:myObservable, options:["A", "B"]\'></select>',e(undefined),expect(e()).toEqual(undefined),ko.applyBindings({myObservable:e},testNode),expect(e()).toEqual("A")}),it("When non-empty, should reject model values that don't match any option value, resetting the model value to whatever is visibly selected in the UI",function(){var e=new ko.observable("B");testNode.innerHTML='<select data-bind=\'options:["A", "B", "C"], value:myObservable\'></select>',ko.applyBindings({myObservable:e},testNode),expect(testNode.childNodes[0].selectedIndex).toEqual(1),e("D"),expect(e()).toEqual("B"),e(null),expect(e()).toEqual("B")}),it("Should support numerical option values, which are not implicitly converted to strings",function(){var e=new ko.observable(30);testNode.innerHTML="<select data-bind='options:[10,20,30,40], value:myObservable'></select>",ko.applyBindings({myObservable:e},testNode),expect(testNode.childNodes[0].selectedIndex).toEqual(2),testNode.childNodes[0].selectedIndex=1,ko.utils.triggerEvent(testNode.childNodes[0],"change"),expect(typeof e()).toEqual("number"),expect(e()).toEqual(20)}),it("Should always use value (and not text) when options have value attributes",function(){var e=new ko.observable("A");testNode.innerHTML="<select data-bind='value:myObservable'><option value=''>A</option><option value='A'>B</option></select>",ko.applyBindings({myObservable:e},testNode);var t=testNode.childNodes[0];expect(t.selectedIndex).toEqual(1),t.selectedIndex=0,ko.utils.triggerEvent(t,"change"),expect(e()).toEqual("")}),it("Should use text value when options have text values but no value attribute",function(){var e=new ko.observable("B");testNode.innerHTML="<select data-bind='value:myObservable'><option>A</option><option>B</option><option>C</option></select>",ko.applyBindings({myObservable:e},testNode);var t=testNode.childNodes[0];expect(t.selectedIndex).toEqual(1),t.selectedIndex=0,ko.utils.triggerEvent(t,"change"),expect(e()).toEqual("A"),e("C"),expect(t.selectedIndex).toEqual(2)}),describe("Using valueAllowUnset option",function(){it("Should display the caption when the model value changes to undefined, null, or \"\" when using 'options' binding",function(){var e=ko.observable("B");testNode.innerHTML='<select data-bind=\'options:["A", "B"], optionsCaption:"Select...", value:myObservable, valueAllowUnset:true\'></select>',ko.applyBindings({myObservable:e},testNode);var t=testNode.childNodes[0];t.selectedIndex=2,e(undefined),expect(t.selectedIndex).toEqual(0),t.selectedIndex=2,e(null),expect(t.selectedIndex).toEqual(0),t.selectedIndex=2,e(""),expect(t.selectedIndex).toEqual(0)}),it('Should display the caption when the model value changes to undefined, null, or "" when options specified directly',function(){var e=ko.observable("B");testNode.innerHTML="<select data-bind='value:myObservable, valueAllowUnset:true'><option value=''>Select...</option><option>A</option><option>B</option></select>",ko.applyBindings({myObservable:e},testNode);var t=testNode.childNodes[0];t.selectedIndex=2,e(undefined),expect(t.selectedIndex).toEqual(0),t.selectedIndex=2,e(null),expect(t.selectedIndex).toEqual(0),t.selectedIndex=2,e(""),expect(t.selectedIndex).toEqual(0)}),it("Should select no option value if no option value matches the current model property value",function(){var e=ko.observable();testNode.innerHTML='<select data-bind=\'options:["A", "B"], value:myObservable, valueAllowUnset:true\'></select>',ko.applyBindings({myObservable:e},testNode),expect(testNode.childNodes[0].selectedIndex).toEqual(-1),expect(e()).toEqual(undefined)}),it("Should select no option value if model value does't match any option value",function(){var e=ko.observable("B");testNode.innerHTML='<select data-bind=\'options:["A", "B", "C"], value:myObservable, valueAllowUnset:true\'></select>',ko.applyBindings({myObservable:e},testNode),expect(testNode.childNodes[0].selectedIndex).toEqual(1),e("D"),expect(testNode.childNodes[0].selectedIndex).toEqual(-1)}),it("Should maintain model value and update selection when options change",function(){var e=ko.observable("D"),t=ko.observableArray(["A","B"]);testNode.innerHTML="<select data-bind='options:myOptions, value:myObservable, valueAllowUnset:true'></select>",ko.applyBindings({myObservable:e,myOptions:t},testNode),expect(testNode.childNodes[0].selectedIndex).toEqual(-1),expect(e()).toEqual("D"),t(["B","C"]),expect(testNode.childNodes[0].selectedIndex).toEqual(-1),expect(e()).toEqual("D"),t(["C","D"]),expect(testNode.childNodes[0].selectedIndex).toEqual(1),expect(e()).toEqual("D"),t(["E","F"]),expect(testNode.childNodes[0].selectedIndex).toEqual(-1),expect(e()).toEqual("D")}),it("Should maintain model value and update selection when changing observable option text or value",function(){var e=ko.observable("B"),t=[{name:ko.observable("Annie"),id:ko.observable("A")},{name:ko.observable("Bert"),id:ko.observable("B")}];testNode.innerHTML="<select data-bind=\"options:people, optionsText:'name', optionsValue:'id', value:selected, valueAllowUnset:true\"></select>",ko.applyBindings({people:t,selected:e},testNode),expect(testNode.childNodes[0].selectedIndex).toEqual(1),expect(testNode.childNodes[0]).toHaveTexts(["Annie","Bert"]),expect(e()).toEqual("B"),t[1].name("Charles"),expect(testNode.childNodes[0].selectedIndex).toEqual(1),expect(testNode.childNodes[0]).toHaveTexts(["Annie","Charles"]),expect(e()).toEqual("B"),t[1].id("C"),expect(testNode.childNodes[0].selectedIndex).toEqual(-1),expect(e()).toEqual("B"),t[0].name("Amelia"),expect(testNode.childNodes[0].selectedIndex).toEqual(-1),expect(e()).toEqual("B")})})}),describe("Acts like 'checkedValue' on a checkbox or radio",function(){it("Should update value, but not respond to events when on a checkbox",function(){var e=new ko.observable("B");testNode.innerHTML="<input type='checkbox' data-bind='value: myObservable' />",ko.applyBindings({myObservable:e},testNode);var t=testNode.childNodes[0];expect(t.value).toEqual("B"),e("C"),expect(t.value).toEqual("C"),t.value="D",ko.utils.triggerEvent(t,"change"),expect(e()).toEqual("C")}),it("Should update value, but not respond to events when on a radio",function(){var e=new ko.observable("B");testNode.innerHTML="<input type='radio' data-bind='value: myObservable' />",ko.applyBindings({myObservable:e},testNode);var t=testNode.childNodes[0];expect(t.value).toEqual("B"),e("C"),expect(t.value).toEqual("C"),t.value="D",ko.utils.triggerEvent(t,"change"),expect(e()).toEqual("C")})})})}.call(e),t})})(this);