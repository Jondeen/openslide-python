(function(e){var t;define([],function(){return function(){describe("Dependent Observable DOM",function(){beforeEach(jasmine.prepareTestNode),it("Should register DOM node disposal callback only if active after the initial evaluation",function(){var e=document.createElement("DIV"),t=ko.observable("initial"),n=ko.dependentObservable({read:function(){return t()},disposeWhenNodeIsRemoved:e}),r=document.createElement("DIV");inactiveDependentObservable=ko.dependentObservable({read:function(){return 123},disposeWhenNodeIsRemoved:r}),expect(n.isActive()).toEqual(!0),expect(inactiveDependentObservable.isActive()).toEqual(!1),expect(ko.utils.domData.clear(e)).toEqual(!0),expect(ko.utils.domData.clear(r)).toEqual(!1)}),it("Should dispose when DOM node is removed from the document and computed is re-evaluated",function(){var e=document.createElement("DIV");testNode.appendChild(e);var t=ko.observable("initial"),n=ko.computed({read:function(){return t()},disposeWhenNodeIsRemoved:e});t("second"),expect(n.isActive()).toEqual(!0),testNode.removeChild(e),t("third"),expect(n.isActive()).toEqual(!1)}),it("Should dispose when DOM node is removed from the document, but not before it's added",function(){var e=document.createElement("DIV"),t=ko.observable("initial"),n=ko.computed({read:function(){return t()},disposeWhenNodeIsRemoved:e});t("second"),expect(n.isActive()).toEqual(!0),testNode.appendChild(e),t("third"),expect(n.isActive()).toEqual(!0),testNode.removeChild(e),t("fourth"),expect(n.isActive()).toEqual(!1)})})}.call(e),t})})(this);