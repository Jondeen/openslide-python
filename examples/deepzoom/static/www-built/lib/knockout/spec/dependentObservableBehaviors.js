(function(e){var t;define([],function(){return function(){describe("Dependent Observable",function(){it("Should be subscribable",function(){var e=ko.computed(function(){});expect(ko.isSubscribable(e)).toEqual(!0)}),it("Should advertise that instances are observable",function(){var e=ko.computed(function(){});expect(ko.isObservable(e)).toEqual(!0)}),it("Should advertise that instances are computed",function(){var e=ko.computed(function(){});expect(ko.isComputed(e)).toEqual(!0)}),it("Should advertise that instances cannot have values written to them",function(){var e=ko.computed(function(){});expect(ko.isWriteableObservable(e)).toEqual(!1),expect(ko.isWritableObservable(e)).toEqual(!1)}),it("Should require an evaluator function as constructor param",function(){expect(function(){ko.computed()}).toThrow()}),it("Should be able to read the current value of the evaluator function",function(){var e=ko.computed(function(){return 123});expect(e()).toEqual(123)}),it('Should not be able to write a value to it if there is no "write" callback',function(){var e=ko.computed(function(){return 123});expect(function(){e(456)}).toThrow(),expect(e()).toEqual(123)}),it('Should invoke the "write" callback, where present, if you attempt to write a value to it',function(){var e,t,n=ko.computed({read:function(){},write:function(n){e=n,t=this}}),r={depObs:n};r.depObs("some value"),expect(e).toEqual("some value"),expect(t).toEqual(function(){return this}.call())}),it("Should be able to write to multiple computed properties on a model object using chaining syntax",function(){var e={prop1:ko.computed({read:function(){},write:function(e){expect(e).toEqual("prop1")}}),prop2:ko.computed({read:function(){},write:function(e){expect(e).toEqual("prop2")}})};e.prop1("prop1").prop2("prop2")}),it("Should be able to use Function.prototype methods to access/update",function(){var e=ko.computed({read:function(){return"A"},write:function(e){}}),t={};expect(e.call(null)).toEqual("A"),expect(e.apply(null,[])).toBe("A"),expect(e.call(t,"B")).toBe(t)}),it('Should use options.owner as "this" when invoking the "write" callback, and can pass multiple parameters',function(){var e,t,n={},r=ko.computed({read:function(){},write:function(){e=Array.prototype.slice.call(arguments,0),t=this},owner:n});r("first",2,["third1","third2"]),expect(e.length).toEqual(3),expect(e[0]).toEqual("first"),expect(e[1]).toEqual(2),expect(e[2]).toEqual(["third1","third2"]),expect(t).toEqual(n)}),it('Should use the second arg (evaluatorFunctionTarget) for "this" when calling read/write if no options.owner was given',function(){var e={},t,n,r=ko.computed({read:function(){t=this},write:function(){n=this}},e);r("force invocation of write"),expect(t).toEqual(e),expect(n).toEqual(e)}),it('Should be able to pass evaluator function using "options" parameter called "read"',function(){var e=ko.computed({read:function(){return 123}});expect(e()).toEqual(123)}),it("Should cache result of evaluator function and not call it again until dependencies change",function(){var e=0,t=ko.computed(function(){return e++,123});expect(t()).toEqual(123),expect(t()).toEqual(123),expect(e).toEqual(1)}),it("Should automatically update value when a dependency changes",function(){var e=new ko.observable(1),t=ko.computed(function(){return e()+1});expect(t()).toEqual(2),e(50),expect(t()).toEqual(51)}),it("Should be able to use 'peek' on an observable to avoid a dependency",function(){var e=ko.observable(1),t=ko.computed(function(){return e.peek()+1});expect(t()).toEqual(2),e(50),expect(t()).toEqual(2)}),it("Should be able to use 'ko.ignoreDependencies' within a computed to avoid dependencies",function(){var e=ko.observable(1),t=ko.dependentObservable(function(){return ko.ignoreDependencies(function(){return e()+1})});expect(t()).toEqual(2),e(50),expect(t()).toEqual(2)}),it("Should unsubscribe from previous dependencies each time a dependency changes",function(){var e=new ko.observable("A"),t=new ko.observable("B"),n="A",r=0,i=ko.computed(function(){return r++,n=="A"?e():t()});expect(i()).toEqual("A"),expect(r).toEqual(1),t("B2"),expect(r).toEqual(1),n="B",e("A2"),expect(i()).toEqual("B2"),expect(r).toEqual(2),e("A3"),expect(r).toEqual(2)}),it("Should notify subscribers of changes",function(){var e,t=new ko.observable(1),n=ko.computed(function(){return t()+1});n.subscribe(function(t){e=t}),expect(e).toEqual(undefined),t(2),expect(e).toEqual(3)}),it('Should notify "beforeChange" subscribers before changes',function(){var e,t=new ko.observable(1),n=ko.computed(function(){return t()+1});n.subscribe(function(t){e=t},null,"beforeChange"),expect(e).toEqual(undefined),t(2),expect(e).toEqual(2),expect(n()).toEqual(3)}),it("Should only update once when each dependency changes, even if evaluation calls the dependency multiple times",function(){var e=[],t=new ko.observable,n=ko.computed(function(){return t()*t()});n.subscribe(function(t){e.push(t)}),t(2),expect(e.length).toEqual(1),expect(e[0]).toEqual(4)}),it("Should be able to chain computed observables",function(){var e=new ko.observable(1),t=ko.computed(function(){return e()+1}),n=ko.computed(function(){return t()+1});expect(n()).toEqual(3),e(11),expect(n()).toEqual(13)}),it("Should be able to use 'peek' on a computed observable to avoid a dependency",function(){var e=new ko.observable(1),t=ko.computed(function(){return e()+1}),n=ko.computed(function(){return t.peek()+1});expect(n()).toEqual(3),expect(n.isActive()).toEqual(!1),e(11),expect(n()).toEqual(3)}),it('Should accept "owner" parameter to define the object on which the evaluator function should be called',function(){var e=new function(){this.greeting="hello",this.fullMessageWithoutOwner=ko.computed(function(){return this.greeting+" world"}),this.fullMessageWithOwner=ko.computed(function(){return this.greeting+" world"},this)};expect(e.fullMessageWithoutOwner()).toEqual("undefined world"),expect(e.fullMessageWithOwner()).toEqual("hello world")}),it("Should dispose and not call its evaluator function when the disposeWhen function returns true",function(){var e=new ko.observable(100),t=!1,n=0,r=ko.computed(function(){return n++,e()+1},null,{disposeWhen:function(){return t}});expect(n).toEqual(1),expect(r.getDependenciesCount()).toEqual(1),expect(r.isActive()).toEqual(!0),t=!0,e(101),expect(n).toEqual(1),expect(r.getDependenciesCount()).toEqual(0),expect(r.isActive()).toEqual(!1)}),it("Should dispose itself as soon as disposeWhen returns true, as long as it isn't waiting for a DOM node to be removed",function(){var e=ko.observable(100),t=ko.computed(e,null,{disposeWhen:function(){return!0}});expect(e.getSubscriptionsCount()).toEqual(0),expect(t.isActive()).toEqual(!1)}),it("Should delay disposal until after disposeWhen returns false if it is waiting for a DOM node to be removed",function(){var e=ko.observable(100),t=!0,n=ko.computed(e,null,{disposeWhen:function(){return t},disposeWhenNodeIsRemoved:!0});expect(e.getSubscriptionsCount()).toEqual(1),expect(n.isActive()).toEqual(!0),t=!1,e(101),expect(e.getSubscriptionsCount()).toEqual(1),expect(n.isActive()).toEqual(!0),t=!0,e(102),expect(e.getSubscriptionsCount()).toEqual(0),expect(n.isActive()).toEqual(!1)}),it("Should describe itself as active if the evaluator has dependencies on its first run",function(){var e=ko.observable("initial"),t=ko.computed(function(){return e()});expect(t.isActive()).toEqual(!0)}),it("Should describe itself as inactive if the evaluator has no dependencies on its first run",function(){var e=ko.computed(function(){return 123});expect(e.isActive()).toEqual(!1)}),it("Should describe itself as inactive if subsequent runs of the evaluator result in there being no dependencies",function(){var e=ko.observable("initial"),t=!0,n=ko.computed(function(){return t&&e()});expect(n.isActive()).toEqual(!0),t=!1,e("modified"),expect(n.isActive()).toEqual(!1)}),it('Should advertise that instances *can* have values written to them if you supply a "write" callback',function(){var e=ko.computed({read:function(){},write:function(){}});expect(ko.isWriteableObservable(e)).toEqual(!0),expect(ko.isWritableObservable(e)).toEqual(!0)}),it("Should allow deferring of evaluation (and hence dependency detection)",function(){var e=0,t=ko.computed({read:function(){return e++,123},deferEvaluation:!0});expect(e).toEqual(0),expect(t()).toEqual(123),expect(e).toEqual(1)}),it('Should perform dependency detection when subscribed to when constructed with "deferEvaluation"',function(){var e=ko.observable(1),t=ko.computed({read:e,deferEvaluation:!0}),n=ko.observable();expect(t.getDependenciesCount()).toEqual(0),t.subscribe(n),expect(t.getDependenciesCount()).toEqual(1),expect(n()).toEqual(undefined),e(42),expect(n()).toEqual(42)}),it('Should fire "awake" event when deferred computed is first evaluated',function(){var e=ko.observable("A"),t=ko.computed({read:e,deferEvaluation:!0}),n=jasmine.createSpy("notifySpy");t.subscribe(n,null,"awake"),expect(n).not.toHaveBeenCalled(),expect(t()).toEqual("A"),expect(n).toHaveBeenCalledWith("A"),expect(n.calls.length).toBe(1),n.reset(),t.subscribe(function(){}),e("B"),t(),expect(n).not.toHaveBeenCalled()}),it("Should prevent recursive calling of read function",function(){var e=ko.observable(0),t=ko.computed(function(){e(e()+1)})}),it("Should not subscribe to observables accessed through change notifications of a computed",function(){var e=ko.observable(),t=ko.observable(),n=ko.computed(function(){return e()});expect(n.getDependenciesCount()).toEqual(1),n.subscribe(function(){t()}),e(1),expect(n.getDependenciesCount()).toEqual(1),n.subscribe(function(){t()},null,"beforeChange"),e(2),expect(n.getDependenciesCount()).toEqual(1)}),it("Should not subscribe to observables accessed through change notifications of a modified observable",function(){var e=ko.observable(),t=ko.observable(),n=ko.observable(),r=ko.computed(function(){n(e())});expect(r.getDependenciesCount()).toEqual(1),n.subscribe(function(){t()}),e(1),expect(r.getDependenciesCount()).toEqual(1),n.subscribe(function(){t()},null,"beforeChange"),e(2),expect(r.getDependenciesCount()).toEqual(1)}),it("Should be able to re-evaluate a computed that previously threw an exception",function(){var e=ko.observable(!0),t=ko.observable(1),n=ko.computed(function(){if(!e())throw Error("Error during computed evaluation");return t()});expect(n()).toEqual(1),expect(function(){e(!1)}).toThrow("Error during computed evaluation"),expect(n()).toEqual(1),expect(n.getDependenciesCount()).toEqual(1),t(2),expect(n()).toEqual(1),e(1),expect(n()).toEqual(2)}),it('Should expose a "notify" extender that can configure a computed to notify on all changes',function(){var e=[],t=new ko.observable(1),n=new ko.computed(function(){return t()});n.subscribe(function(t){e.push(t)}),expect(e).toEqual([]),t.valueHasMutated(),expect(e).toEqual([]),n.extend({notify:"always"}),t.valueHasMutated(),expect(e).toEqual([1])}),it("Should allow long chains without overflowing the stack",function(){var e=200,t=ko.observable(0),n=t;for(var r=0;r<e;r++)(function(){var e=n;n=ko.computed(function(){return e()+1})})();var i=ko.computed(function(){return n()+t()});t(1),expect(i()).toEqual(e+2)}),it("Should inherit any properties defined on ko.subscribable.fn or ko.computed.fn",function(){this.after(function(){delete ko.subscribable.fn.customProp,delete ko.subscribable.fn.customFunc,delete ko.computed.fn.customFunc}),ko.subscribable.fn.customProp="subscribable value",ko.subscribable.fn.customFunc=function(){throw new Error("Shouldn't be reachable")},ko.computed.fn.customFunc=function(){return this()};var e=ko.computed(function(){return 123});expect(e.customProp).toEqual("subscribable value"),expect(e.customFunc()).toEqual(123)}),it('Should have access to functions added to "fn" on existing instances on supported browsers',function(){if(!jasmine.browserSupportsProtoAssignment)return;this.after(function(){delete ko.subscribable.fn.customFunction1,delete ko.computed.fn.customFunction2});var e=ko.computed(function(){}),t=function(){},n=function(){};ko.subscribable.fn.customFunction1=t,ko.computed.fn.customFunction2=n,expect(e.customFunction1).toBe(t),expect(e.customFunction2).toBe(n)}),it("Should not evaluate (or add dependencies) after it has been disposed",function(){var e=0,t=ko.observable(0),n=ko.computed(function(){return++e+t()});expect(e).toEqual(1),n.dispose(),t(1),expect(e).toEqual(1),expect(n()).toEqual(1),expect(n.getDependenciesCount()).toEqual(0)}),it('Should not evaluate (or add dependencies) after it has been disposed if created with "deferEvaluation"',function(){var e=0,t=ko.observable(0),n=ko.computed({read:function(){return++e+t()},deferEvaluation:!0});expect(e).toEqual(0),n.dispose(),t(1),expect(e).toEqual(0),expect(n()).toEqual(undefined),expect(n.getDependenciesCount()).toEqual(0)}),it("Should not add dependencies if disposed during evaluation",function(){var e=0,t=ko.observable(!1),n=ko.observable(0),r=ko.computed(function(){return t()&&r.dispose(),++e+n()});expect(e).toEqual(1),expect(r()).toEqual(1),expect(r.getDependenciesCount()).toEqual(2),expect(n.getSubscriptionsCount()).toEqual(1),t(!0),expect(e).toEqual(2),expect(r()).toEqual(2),expect(r.getDependenciesCount()).toEqual(0),expect(n.getSubscriptionsCount()).toEqual(0)}),describe("Context",function(){it("Should accurately report initial evaluation",function(){var e=ko.observable(1),t=0,n=ko.computed(function(){return++t,e(),ko.computedContext.isInitial()});expect(t).toEqual(1),expect(n()).toEqual(!0),e(2),expect(t).toEqual(2),expect(n()).toEqual(!1),expect(ko.computedContext.isInitial()).toBeUndefined()}),it("Should accurately report initial evaluation when deferEvaluation is true",function(){var e=ko.observable(1),t=0,n=ko.computed(function(){return++t,e(),ko.computedContext.isInitial()},null,{deferEvaluation:!0});expect(t).toEqual(0),expect(n()).toEqual(!0),expect(t).toEqual(1),e(2),expect(t).toEqual(2),expect(n()).toEqual(!1)}),it("Should accurately report the number of dependencies",function(){var e=ko.observable(1),t=ko.observable(1),n=0,r=ko.computed(function(){++n,expect(ko.computedContext.getDependenciesCount()).toEqual(0),e(),expect(ko.computedContext.getDependenciesCount()).toEqual(1),t(),expect(ko.computedContext.getDependenciesCount()).toEqual(2),e(),expect(ko.computedContext.getDependenciesCount()).toEqual(2)});expect(n).toEqual(1),expect(r.getDependenciesCount()).toEqual(2),e(2),expect(n).toEqual(2),expect(r.getDependenciesCount()).toEqual(2),expect(ko.computedContext.getDependenciesCount()).toBeUndefined()})})})}.call(e),t})})(this);