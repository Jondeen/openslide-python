(function(e){var t;define([],function(){return function(){describe("Components: Custom elements",function(){beforeEach(function(){jasmine.prepareTestNode(),jasmine.Clock.useMock()}),afterEach(function(){jasmine.Clock.reset(),ko.components.unregister("test-component")}),it("Inserts components into custom elements with matching names",function(){ko.components.register("test-component",{template:'custom element <span data-bind="text: 123"></span>'});var e="<div>hello <test-component></test-component></div>";testNode.innerHTML=e,ko.applyBindings(null,testNode),expect(testNode).toContainHtml(e),jasmine.Clock.tick(1),expect(testNode).toContainHtml('<div>hello <test-component>custom element <span data-bind="text: 123">123</span></test-component></div>')}),it("Is possible to override getComponentNameForNode to determine which component goes into which element",function(){ko.components.register("test-component",{template:"custom element"}),this.restoreAfter(ko.components,"getComponentNameForNode"),testNode.innerHTML="<div>hello <a>&nbsp;</a> <b>ignored</b></div>",ko.components.getComponentNameForNode=function(e){return e.tagName==="A"?"test-component":null},ko.applyBindings(null,testNode),jasmine.Clock.tick(1),expect(testNode).toContainHtml("<div>hello <a>custom element</a> <b>ignored</b></div>")}),it("Is possible to have regular data-bind bindings on a custom element, as long as they don't attempt to control descendants",function(){ko.components.register("test-component",{template:"custom element"}),testNode.innerHTML='<test-component data-bind="visible: shouldshow"></test-component>';var e={shouldshow:ko.observable(!0)};ko.applyBindings(e,testNode),jasmine.Clock.tick(1),expect(testNode).toContainHtml('<test-component data-bind="visible: shouldshow">custom element</test-component>'),expect(testNode.childNodes[0].style.display).not.toBe("none"),e.shouldshow(!1),expect(testNode.childNodes[0].style.display).toBe("none"),expect(testNode.childNodes[0].innerHTML).toBe("custom element")}),it("Is not possible to have regular data-bind bindings on a custom element if they also attempt to control descendants",function(){ko.components.register("test-component",{template:"custom element"}),testNode.innerHTML='<test-component data-bind="if: true"></test-component>',expect(function(){ko.applyBindings(null,testNode)}).toThrowContaining("Multiple bindings (if and component) are trying to control descendant bindings of the same element.")}),it("Is possible to call applyBindings directly on a custom element",function(){ko.components.register("test-component",{template:"custom element"}),testNode.innerHTML="<test-component></test-component>";var e=testNode.childNodes[0];expect(e.tagName.toLowerCase()).toBe("test-component"),ko.applyBindings(null,e),jasmine.Clock.tick(1),expect(e.innerHTML).toBe("custom element")}),it("Throws if you try to duplicate the 'component' binding on a custom element that matches a component",function(){ko.components.register("test-component",{template:"custom element"}),testNode.innerHTML='<test-component data-bind="component: {}"></test-component>',expect(function(){ko.applyBindings(null,testNode)}).toThrowContaining('Cannot use the "component" binding on a custom element matching a component')}),it("Is possible to pass literal values",function(){var e=[];ko.components.register("test-component",{template:"Ignored",viewModel:function(t){e.push(t),ko.utils.objectForEach(t,function(e,n){e!=="$raw"&&(expect(ko.isComputed(t.$raw[e])).toBe(!0),expect(t.$raw[e]()).toBe(n))})}}),testNode.innerHTML="<test-component params=\"nothing: null, num: 123, bool: true, obj: { abc: 123 }, str: 'mystr'\"></test-component>",ko.applyBindings(null,testNode),jasmine.Clock.tick(1),delete e[0].$raw,expect(e).toEqual([{nothing:null,num:123,bool:!0,obj:{abc:123},str:"mystr"}])}),it("Supplies an empty params object (with empty $raw) if a custom element has no params attribute",function(){var e=[];ko.components.register("test-component",{template:"Ignored",viewModel:function(t){e.push(t)}}),testNode.innerHTML="<test-component></test-component>",ko.applyBindings(null,testNode),jasmine.Clock.tick(1),expect(e).toEqual([{$raw:{}}])}),it("Supplies an empty params object (with empty $raw) if a custom element has an empty whitespace params attribute",function(){var e=[];ko.components.register("test-component",{template:"Ignored",viewModel:function(t){e.push(t)}}),testNode.innerHTML='<test-component params=" "></test-component>',ko.applyBindings(null,testNode),jasmine.Clock.tick(1),expect(e).toEqual([{$raw:{}}])}),it("Should not confuse parameters with bindings",function(){this.restoreAfter(ko,"getBindingHandler");var e=[];ko.getBindingHandler=function(t){e.push(t)},ko.components.register("test-component",{}),testNode.innerHTML='<test-component params="value: value"></test-component>',ko.applyBindings({value:123},testNode),expect(e).toEqual(["component"])}),it("Should update component when observable view model changes",function(){ko.components.register("test-component",{template:'<p>the value: <span data-bind="text: textToShow"></span></p>'}),testNode.innerHTML='<test-component params="textToShow: value"></test-component>';var e=ko.observable({value:"A"});ko.applyBindings(e,testNode),jasmine.Clock.tick(1),expect(testNode).toContainText("the value: A"),e({value:"Z"}),jasmine.Clock.tick(1),expect(testNode).toContainText("the value: Z")}),it("Is possible to pass observable instances",function(){ko.components.register("test-component",{template:'<p>the observable: <span data-bind="text: receivedobservable"></span></p>',viewModel:function(e){this.receivedobservable=e.suppliedobservable,expect(this.receivedobservable.subprop).toBe("subprop"),this.dispose=function(){this.wasDisposed=!0},expect(ko.isComputed(e.$raw.suppliedobservable)).toBe(!0),expect(e.$raw.suppliedobservable()).toBe(e.suppliedobservable)}});var e=ko.observable(1);e.subprop="subprop",testNode.innerHTML='<test-component params="suppliedobservable: myobservable"></test-component>',ko.applyBindings({myobservable:e},testNode),jasmine.Clock.tick(1);var t=ko.dataFor(testNode.firstChild.firstChild);expect(testNode.firstChild).toContainText("the observable: 1"),e(2),expect(testNode.firstChild).toContainText("the observable: 2"),expect(ko.dataFor(testNode.firstChild.firstChild)).toBe(t),expect(t.wasDisposed).not.toBe(!0)}),it("Is possible to pass expressions that can vary observably",function(){var e={myobservable:ko.observable("Alpha")},t=0;ko.components.register("test-component",{template:'<p>the string reversed: <span data-bind="text: receivedobservable"></span></p>',viewModel:function(n){t++,this.receivedobservable=n.suppliedobservable,this.dispose=function(){this.wasDisposed=!0},expect(this.receivedobservable).not.toBe(e.myobservable),expect(ko.isComputed(this.receivedobservable)).toBe(!0),expect(ko.isWritableObservable(this.receivedobservable)).toBe(!1),expect(ko.isComputed(n.$raw.suppliedobservable)).toBe(!0),expect(n.$raw.suppliedobservable()).toBe(n.suppliedobservable())}}),testNode.innerHTML='<test-component params=\'suppliedobservable: myobservable().split("").reverse().join("")\'></test-component>',ko.applyBindings(e,testNode),jasmine.Clock.tick(1),expect(testNode.firstChild).toContainText("the string reversed: ahplA");var n=ko.dataFor(testNode.firstChild.firstChild);expect(t).toBe(1),expect(e.myobservable.getSubscriptionsCount()).toBe(1),e.myobservable("Beta"),expect(testNode.firstChild).toContainText("the string reversed: ateB"),expect(t).toBe(1),expect(ko.dataFor(testNode.firstChild.firstChild)).toBe(n),expect(n.wasDisposed).not.toBe(!0),expect(e.myobservable.getSubscriptionsCount()).toBe(1),ko.cleanNode(testNode),expect(n.wasDisposed).toBe(!0),expect(e.myobservable.getSubscriptionsCount()).toBe(0)}),it("Is possible to pass expressions that can vary observably and evaluate as writable observable instances",function(){var e=0;ko.components.register("test-component",{template:'<input data-bind="value: myval"/>',viewModel:function(n){e++,this.myval=n.somevalue,expect(ko.isWritableObservable(this.myval)).toBe(!0),expect(ko.isComputed(this.myval)).toBe(!0);var r=n.$raw.somevalue();expect(ko.isObservable(r)).toBe(!0),expect(ko.isComputed(r)).toBe(!1),r()==="inner1"&&expect(r).toBe(t)}});var t=ko.observable("inner1"),n=ko.observable({inner:t});testNode.innerHTML='<test-component params="somevalue: outer().inner"></test-component>',ko.applyBindings({outer:n},testNode),jasmine.Clock.tick(1),expect(testNode.childNodes[0].childNodes[0].value).toEqual("inner1"),expect(n.getSubscriptionsCount()).toBe(1),expect(t.getSubscriptionsCount()).toBe(1),expect(e).toBe(1),t("inner2"),expect(testNode.childNodes[0].childNodes[0].value).toEqual("inner2"),expect(n.getSubscriptionsCount()).toBe(1),expect(t.getSubscriptionsCount()).toBe(1),expect(e).toBe(1),testNode.childNodes[0].childNodes[0].value="inner3",ko.utils.triggerEvent(testNode.childNodes[0].childNodes[0],"change"),expect(t()).toEqual("inner3");var r=ko.observable("newinner");n({inner:r}),expect(testNode.childNodes[0].childNodes[0].value).toEqual("newinner"),expect(n.getSubscriptionsCount()).toBe(1),expect(t.getSubscriptionsCount()).toBe(0),expect(r.getSubscriptionsCount()).toBe(1),expect(e).toBe(1),testNode.childNodes[0].childNodes[0].value="newinner2",ko.utils.triggerEvent(testNode.childNodes[0].childNodes[0],"change"),expect(r()).toEqual("newinner2"),expect(t()).toEqual("inner3"),ko.cleanNode(testNode),expect(n.getSubscriptionsCount()).toBe(0),expect(t.getSubscriptionsCount()).toBe(0),expect(r.getSubscriptionsCount()).toBe(0)}),it('Supplies any custom parameter called "$raw" in preference to the function that yields raw parameter values',function(){var e=0,t={};ko.components.register("test-component",{template:"Ignored",viewModel:function(n){e++,expect(n.$raw).toBe(t)}}),testNode.innerHTML='<test-component params="$raw: suppliedValue"></test-component>',ko.applyBindings({suppliedValue:t},testNode),jasmine.Clock.tick(1),expect(e).toBe(1)}),it("Disposes the component when the custom element is cleaned",function(){var e={dispose:function(){this.wasDisposed=!0}};ko.components.register("test-component",{template:"custom element",viewModel:{instance:e}}),testNode.innerHTML="<test-component></test-component>",ko.applyBindings(null,testNode),jasmine.Clock.tick(1),expect(testNode.firstChild).toContainHtml("custom element"),expect(e.wasDisposed).not.toBe(!0),ko.cleanNode(testNode.firstChild),expect(e.wasDisposed).toBe(!0)}),it("Can nest custom elements",function(){this.after(function(){ko.components.unregister("outer-component"),ko.components.unregister("inner-component")}),ko.components.register("inner-component",{template:'the inner component with value [<span data-bind="text: innerval"></span>]'}),ko.components.register("outer-component",{template:'the outer component [<inner-component params="innerval: outerval.innerval"></inner-component>] goodbye'});var e='<div>hello [<outer-component params="outerval: outerval"></outer-component>] world</div>';testNode.innerHTML=e,ko.applyBindings({outerval:{innerval:"my value"}},testNode);try{jasmine.Clock.tick(1),expect(testNode).toContainText("hello [the outer component [the inner component with value [my value]] goodbye] world")}catch(t){if(t.message.indexOf("Unexpected call to method or property access.")>=0&&!window.jQuery)return;throw t}}),it('Is possible to set up components that receive, inject, and bind templates supplied by the user of the component (sometimes called "templated components" or "transclusion")',function(){this.after(function(){ko.components.unregister("special-list")}),ko.components.register("special-list",{template:'<ul class="my-special-list" data-bind="foreach: specialListItems"><li data-bind="template: { nodes: $component.suppliedItemTemplate }"></li></ul>',viewModel:{createViewModel:function(e,t){return{specialListItems:e.items,suppliedItemTemplate:t.templateNodes}}}}),testNode.innerHTML='<h1>Cheeses</h1><special-list params="items: cheeses"><em data-bind="text: name">x</em> has quality <em data-bind="text: quality">x</em></special-list>',ko.applyBindings({cheeses:[{name:"brie",quality:7},{name:"cheddar",quality:9},{name:"roquefort",quality:3}]},testNode),jasmine.Clock.tick(1),expect(testNode.childNodes[0]).toContainText("Cheeses"),expect(testNode.childNodes[1].childNodes[0].tagName.toLowerCase()).toEqual("ul"),expect(testNode.childNodes[1].childNodes[0].className).toEqual("my-special-list"),expect(testNode.childNodes[1].childNodes[0]).toContainHtml('<li data-bind="template: { nodes: $component.supplieditemtemplate }"><em data-bind="text: name">brie</em> has quality <em data-bind="text: quality">7</em></li><li data-bind="template: { nodes: $component.supplieditemtemplate }"><em data-bind="text: name">cheddar</em> has quality <em data-bind="text: quality">9</em></li><li data-bind="template: { nodes: $component.supplieditemtemplate }"><em data-bind="text: name">roquefort</em> has quality <em data-bind="text: quality">3</em></li>')})})}.call(e),t})})(this);