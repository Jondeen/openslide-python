(function(e){var t;define([],function(){return function(){describe("Observable Array",function(){beforeEach(function(){testObservableArray=new ko.observableArray([1,2,3]),notifiedValues=[],testObservableArray.subscribe(function(e){notifiedValues.push(e?e.slice(0):e)}),beforeNotifiedValues=[],testObservableArray.subscribe(function(e){beforeNotifiedValues.push(e?e.slice(0):e)},null,"beforeChange")}),it("Should be observable",function(){expect(ko.isObservable(testObservableArray)).toEqual(!0)}),it("Should initialize to empty array if you pass no args to constructor",function(){var e=new ko.observableArray;expect(e().length).toEqual(0)}),it("Should require constructor arg, if given, to be array-like or null or undefined",function(){expect(function(){ko.observableArray(1)}).toThrow(),expect(function(){ko.observableArray({})}).toThrow(),expect((new ko.observableArray([1,2,3]))().length).toEqual(3),expect((new ko.observableArray(null))().length).toEqual(0),expect((new ko.observableArray(undefined))().length).toEqual(0)}),it("Should be able to write values to it",function(){testObservableArray(["X","Y"]),expect(notifiedValues.length).toEqual(1),expect(notifiedValues[0][0]).toEqual("X"),expect(notifiedValues[0][1]).toEqual("Y")}),it("Should be able to mark single items as destroyed",function(){var e={},t={};testObservableArray([e,t]),testObservableArray.destroy(t),expect(testObservableArray().length).toEqual(2),expect(e._destroy).toEqual(undefined),expect(t._destroy).toEqual(!0)}),it("Should be able to mark multiple items as destroyed",function(){var e={},t={},n={};testObservableArray([e,t,n]),testObservableArray.destroyAll([e,n]),expect(testObservableArray().length).toEqual(3),expect(e._destroy).toEqual(!0),expect(t._destroy).toEqual(undefined),expect(n._destroy).toEqual(!0)}),it("Should be able to mark observable items as destroyed",function(){var e=ko.observable(),t=ko.observable();testObservableArray([e,t]),testObservableArray.destroy(t),expect(testObservableArray().length).toEqual(2),expect(e._destroy).toEqual(undefined),expect(t._destroy).toEqual(!0)}),it("Should be able to mark all items as destroyed by passing no args to destroyAll()",function(){var e={},t={},n={};testObservableArray([e,t,n]),testObservableArray.destroyAll(),expect(testObservableArray().length).toEqual(3),expect(e._destroy).toEqual(!0),expect(t._destroy).toEqual(!0),expect(n._destroy).toEqual(!0)}),it("Should notify subscribers on push",function(){testObservableArray.push("Some new value"),expect(notifiedValues).toEqual([[1,2,3,"Some new value"]])}),it('Should notify "beforeChange" subscribers before push',function(){testObservableArray.push("Some new value"),expect(beforeNotifiedValues).toEqual([[1,2,3]])}),it("Should notify subscribers on pop",function(){var e=testObservableArray.pop();expect(e).toEqual(3),expect(notifiedValues).toEqual([[1,2]])}),it('Should notify "beforeChange" subscribers before pop',function(){var e=testObservableArray.pop();expect(e).toEqual(3),expect(beforeNotifiedValues).toEqual([[1,2,3]])}),it("Should notify subscribers on splice",function(){var e=testObservableArray.splice(1,1);expect(e).toEqual([2]),expect(notifiedValues).toEqual([[1,3]])}),it('Should notify "beforeChange" subscribers before splice',function(){var e=testObservableArray.splice(1,1);expect(e).toEqual([2]),expect(beforeNotifiedValues).toEqual([[1,2,3]])}),it("Should notify subscribers on remove by value",function(){testObservableArray(["Alpha","Beta","Gamma"]),notifiedValues=[];var e=testObservableArray.remove("Beta");expect(e).toEqual(["Beta"]),expect(notifiedValues).toEqual([["Alpha","Gamma"]])}),it("Should notify subscribers on remove by predicate",function(){testObservableArray(["Alpha","Beta","Gamma"]),notifiedValues=[];var e=testObservableArray.remove(function(e){return e=="Beta"});expect(e).toEqual(["Beta"]),expect(notifiedValues).toEqual([["Alpha","Gamma"]])}),it("Should notify subscribers on remove multiple by value",function(){testObservableArray(["Alpha","Beta","Gamma"]),notifiedValues=[];var e=testObservableArray.removeAll(["Gamma","Alpha"]);expect(e).toEqual(["Alpha","Gamma"]),expect(notifiedValues).toEqual([["Beta"]])}),it("Should clear observable array entirely if you pass no args to removeAll()",function(){testObservableArray(["Alpha","Beta","Gamma"]),notifiedValues=[];var e=testObservableArray.removeAll();expect(e).toEqual(["Alpha","Beta","Gamma"]),expect(notifiedValues).toEqual([[]])}),it('Should notify "beforeChange" subscribers before remove',function(){testObservableArray(["Alpha","Beta","Gamma"]),beforeNotifiedValues=[];var e=testObservableArray.remove("Beta");expect(e).toEqual(["Beta"]),expect(beforeNotifiedValues).toEqual([["Alpha","Beta","Gamma"]])}),it("Should not notify subscribers on remove by value with no match",function(){testObservableArray(["Alpha","Beta","Gamma"]),notifiedValues=[];var e=testObservableArray.remove("Delta");expect(e).toEqual([]),expect(notifiedValues).toEqual([])}),it('Should not notify "beforeChange" subscribers before remove by value with no match',function(){testObservableArray(["Alpha","Beta","Gamma"]),beforeNotifiedValues=[];var e=testObservableArray.remove("Delta");expect(e).toEqual([]),expect(beforeNotifiedValues).toEqual([])}),it("Should modify original array on remove",function(){var e=["Alpha","Beta","Gamma"];testObservableArray(e),notifiedValues=[];var t=testObservableArray.remove("Beta");expect(e).toEqual(["Alpha","Gamma"])}),it("Should modify original array on removeAll",function(){var e=["Alpha","Beta","Gamma"];testObservableArray(e),notifiedValues=[];var t=testObservableArray.removeAll();expect(e).toEqual([])}),it("Should remove matching observable items",function(){var e=ko.observable(),t=ko.observable();testObservableArray([e,t]),notifiedValues=[];var n=testObservableArray.remove(t);expect(testObservableArray()).toEqual([e]),expect(n).toEqual([t]),expect(notifiedValues).toEqual([[e]])}),it("Should notify subscribers on replace",function(){testObservableArray(["Alpha","Beta","Gamma"]),notifiedValues=[],testObservableArray.replace("Beta","Delta"),expect(notifiedValues).toEqual([["Alpha","Delta","Gamma"]])}),it('Should notify "beforeChange" subscribers before replace',function(){testObservableArray(["Alpha","Beta","Gamma"]),beforeNotifiedValues=[],testObservableArray.replace("Beta","Delta"),expect(beforeNotifiedValues).toEqual([["Alpha","Beta","Gamma"]])}),it("Should notify subscribers after marking items as destroyed",function(){var e={},t={},n=!1;testObservableArray([e,t]),testObservableArray.subscribe(function(r){expect(e._destroy).toEqual(undefined),expect(t._destroy).toEqual(!0),n=!0}),testObservableArray.destroy(t),expect(n).toEqual(!0)}),it('Should notify "beforeChange" subscribers before marking items as destroyed',function(){var e={},t={},n=!1;testObservableArray([e,t]),testObservableArray.subscribe(function(r){expect(e._destroy).toEqual(undefined),expect(t._destroy).toEqual(undefined),n=!0},null,"beforeChange"),testObservableArray.destroy(t),expect(n).toEqual(!0)}),it("Should be able to return first index of item",function(){testObservableArray(["Alpha","Beta","Gamma"]),expect(testObservableArray.indexOf("Beta")).toEqual(1),expect(testObservableArray.indexOf("Gamma")).toEqual(2),expect(testObservableArray.indexOf("Alpha")).toEqual(0),expect(testObservableArray.indexOf("fake")).toEqual(-1)}),it("Should return 0 when you call myArray.length, and the true length when you call myArray().length",function(){testObservableArray(["Alpha","Beta","Gamma"]),expect(testObservableArray.length).toEqual(0),expect(testObservableArray().length).toEqual(3)}),it("Should be able to call standard mutators without creating a subscription",function(){var e=0,t=ko.observableArray(["Alpha","Beta","Gamma"]),n=ko.computed(function(){t.push("Delta"),t.remove("Beta"),t.splice(2,1),expect(t.peek()).toEqual(["Alpha","Gamma"]),t([{someProp:123}]),t.destroyAll(),expect(t.peek()[0]._destroy).toEqual(!0),t.removeAll(),expect(t.peek()).toEqual([]),e++});expect(e).toEqual(1),expect(t.getSubscriptionsCount()).toEqual(0),t.push("Another"),expect(e).toEqual(1)}),it("Should inherit any properties defined on ko.subscribable.fn, ko.observable.fn, or ko.observableArray.fn",function(){this.after(function(){delete ko.subscribable.fn.subscribableProp,delete ko.subscribable.fn.customProp,delete ko.subscribable.fn.customFunc,delete ko.observable.fn.customProp,delete ko.observable.fn.customFunc,delete ko.observableArray.fn.customProp}),ko.subscribable.fn.subscribableProp="subscribable value",ko.subscribable.fn.customProp="subscribable value - will be overridden",ko.subscribable.fn.customFunc=function(){throw new Error("Shouldn't be reachable")},ko.observable.fn.customProp="observable prop value - will be overridden",ko.observable.fn.customFunc=function(){return this()},ko.observableArray.fn.customProp="observableArray value";var e=ko.observableArray([123]);expect(e.subscribableProp).toEqual("subscribable value"),expect(e.customProp).toEqual("observableArray value"),expect(e.customFunc()).toEqual([123])}),it('Should have access to functions added to "fn" on existing instances on supported browsers',function(){if(!jasmine.browserSupportsProtoAssignment)return;this.after(function(){delete ko.observable.fn.customFunction1,delete ko.observableArray.fn.customFunction2});var e=ko.observableArray(),t=function(){},n=function(){};ko.observable.fn.customFunction1=t,ko.observableArray.fn.customFunction2=n,expect(e.customFunction1).toBe(t),expect(e.customFunction2).toBe(n)})})}.call(e),t})})(this);