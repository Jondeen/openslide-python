(function(root){var amdExports;define([],function(){return function(){var dummyTemplateEngine=function(templates){function dummyTemplateSource(e){this.id=e}var inMemoryTemplates=templates||{},inMemoryTemplateData={};dummyTemplateSource.prototype={text:function(e){return arguments.length>=1&&(inMemoryTemplates[this.id]=e),inMemoryTemplates[this.id]},data:function(e,t){return arguments.length>=2&&(inMemoryTemplateData[this.id]=inMemoryTemplateData[this.id]||{},inMemoryTemplateData[this.id][e]=t),(inMemoryTemplateData[this.id]||{})[e]}},this.makeTemplateSource=function(e){if(typeof e=="string")return new dummyTemplateSource(e);if(e.nodeType==1||e.nodeType==8)return new ko.templateSources.anonymousTemplate(e)},this.renderTemplateSource=function(templateSource,bindingContext,options,templateDocument){var data=bindingContext.$data;templateDocument=templateDocument||document,options=options||{};var templateText=templateSource.text();typeof templateText=="function"&&(templateText=templateText(data,options)),templateText=options.showParams?templateText+", data="+data+", options="+options:templateText;var templateOptions=options.templateOptions,result;with(bindingContext)with(data||{})with(options.templateRenderingVariablesInScope||{}){result=templateText.replace(/\[renderTemplate\:(.*?)\]/g,function(e,t){return ko.renderTemplate(t,data,options)});var evalHandler=function(match,script){try{var evalResult=eval(script);return evalResult===null||evalResult===undefined?"":evalResult.toString()}catch(ex){throw new Error("Error evaluating script: [js: "+script+"]\n\nException: "+ex.toString())}};result=result.replace(/\[\[js\:([\s\S]*?)\]\]/g,evalHandler),result=result.replace(/\[js\:([\s\S]*?)\]/g,evalHandler)}return ko.utils.arrayPushAll([],ko.utils.parseHtmlFragment(result,templateDocument))},this.rewriteTemplate=function(e,t,n){var r=this.makeTemplateSource(e,n);if(typeof r.text()!="function")return ko.templateEngine.prototype.rewriteTemplate.call(this,e,t,n)},this.createJavaScriptEvaluatorBlock=function(e){return"[js:"+e+"]"}};dummyTemplateEngine.prototype=new ko.templateEngine,describe("Templating",function(){beforeEach(jasmine.prepareTestNode),afterEach(function(){ko.setTemplateEngine(new ko.nativeTemplateEngine)}),it("Template engines can return an array of DOM nodes",function(){ko.setTemplateEngine(new dummyTemplateEngine({x:[document.createElement("div"),document.createElement("span")]})),ko.renderTemplate("x",null)}),it("Should not be able to render a template until a template engine is provided",function(){expect(function(){ko.setTemplateEngine(undefined),ko.renderTemplate("someTemplate",{})}).toThrow()}),it("Should be able to render a template into a given DOM element",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"ABC"})),ko.renderTemplate("someTemplate",null,null,testNode),expect(testNode.childNodes.length).toEqual(1),expect(testNode.innerHTML).toEqual("ABC")}),it("Should be able to render an empty template",function(){ko.setTemplateEngine(new dummyTemplateEngine({emptyTemplate:""})),ko.renderTemplate("emptyTemplate",null,null,testNode),expect(testNode.childNodes.length).toEqual(0)}),it("Should be able to access newly rendered/inserted elements in 'afterRender' callback",function(){var e,t,n=function(n,r){expect(n.length).toEqual(1),e=n[0],t=r},r={};ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"ABC"})),ko.renderTemplate("someTemplate",r,{afterRender:n},testNode),expect(e.nodeValue).toEqual("ABC"),expect(t).toEqual(r)}),it("Should automatically rerender into DOM element when dependencies change",function(){var e=new ko.observable("A");ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:function(){return"Value = "+e()}})),ko.renderTemplate("someTemplate",null,null,testNode),expect(testNode.childNodes.length).toEqual(1),expect(testNode.innerHTML).toEqual("Value = A"),e("B"),expect(testNode.childNodes.length).toEqual(1),expect(testNode.innerHTML).toEqual("Value = B")}),it("Should not rerender DOM element if observable accessed in 'afterRender' callback is changed",function(){var e=new ko.observable("A"),t=0,n=function(t,n){e()},r=function(){return"Value = "+ ++t};ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:r})),ko.renderTemplate("someTemplate",{},{afterRender:n},testNode),expect(testNode.childNodes.length).toEqual(1),expect(testNode.innerHTML).toEqual("Value = 1"),e("B"),expect(testNode.childNodes.length).toEqual(1),expect(testNode.innerHTML).toEqual("Value = 1")}),it("If the supplied data item is observable, evaluates it and has subscription on it",function(){var e=new ko.observable("A");ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:function(e){return"Value = "+e}})),ko.renderTemplate("someTemplate",e,null,testNode),expect(testNode.innerHTML).toEqual("Value = A"),e("B"),expect(testNode.innerHTML).toEqual("Value = B")}),it("Should stop updating DOM nodes when the dependency next changes if the DOM node has been removed from the document",function(){var e=new ko.observable("A"),t={someTemplate:function(){return"Value = "+e()}};ko.setTemplateEngine(new dummyTemplateEngine(t)),ko.renderTemplate("someTemplate",null,null,testNode),expect(testNode.childNodes.length).toEqual(1),expect(testNode.innerHTML).toEqual("Value = A"),testNode.parentNode.removeChild(testNode),e("B"),expect(testNode.childNodes.length).toEqual(1),expect(testNode.innerHTML).toEqual("Value = A")}),it("Should be able to pick template via an observable",function(){ko.setTemplateEngine(new dummyTemplateEngine({firstTemplate:"First template output",secondTemplate:"Second template output"}));var e=ko.observable("firstTemplate");ko.renderTemplate(e,null,null,testNode),expect(testNode.innerHTML).toEqual("First template output"),e("secondTemplate"),expect(testNode.innerHTML).toEqual("Second template output")}),it("Should be able to render a template using data-bind syntax",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"template output"})),testNode.innerHTML="<div data-bind='template:\"someTemplate\"'></div>",ko.applyBindings(null,testNode),expect(testNode.childNodes[0].innerHTML).toEqual("template output")}),it("Should remove existing content when rendering a template using data-bind syntax",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"template output"})),testNode.innerHTML="<div data-bind='template:\"someTemplate\"'><span>existing content</span></div>",ko.applyBindings(null,testNode),expect(testNode.childNodes[0].innerHTML).toEqual("template output")}),it("Should be able to tell data-bind syntax which object to pass as data for the template (otherwise, uses viewModel)",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"result = [js: childProp]"})),testNode.innerHTML="<div data-bind='template: { name: \"someTemplate\", data: someProp }'></div>",ko.applyBindings({someProp:{childProp:123}},testNode),expect(testNode.childNodes[0].innerHTML).toEqual("result = 123")}),it("Should re-render a named template when its data item notifies about mutation",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"result = [js: childProp]"})),testNode.innerHTML="<div data-bind='template: { name: \"someTemplate\", data: someProp }'></div>";var e=ko.observable({childProp:123});ko.applyBindings({someProp:e},testNode),expect(testNode.childNodes[0].innerHTML).toEqual("result = 123"),e().childProp=456,e.valueHasMutated(),expect(testNode.childNodes[0].innerHTML).toEqual("result = 456")}),it("Should stop tracking inner observables immediately when the container node is removed from the document",function(){var e=ko.observable("some value");ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"result = [js: childProp()]"})),testNode.innerHTML="<div data-bind='template: { name: \"someTemplate\", data: someProp }'></div>",ko.applyBindings({someProp:{childProp:e}},testNode),expect(e.getSubscriptionsCount()).toEqual(1),ko.removeNode(testNode.childNodes[0]),expect(e.getSubscriptionsCount()).toEqual(0)}),it("Should be able to pick template via an observable model property",function(){ko.setTemplateEngine(new dummyTemplateEngine({firstTemplate:"First template output",secondTemplate:"Second template output"}));var e=ko.observable("firstTemplate");testNode.innerHTML="<div data-bind='template: chosenTemplate'></div>",ko.applyBindings({chosenTemplate:e},testNode),expect(testNode.childNodes[0].innerHTML).toEqual("First template output"),e("secondTemplate"),expect(testNode.childNodes[0].innerHTML).toEqual("Second template output")}),it('Should be able to pick template via an observable model property when specified as "name"',function(){ko.setTemplateEngine(new dummyTemplateEngine({firstTemplate:"First template output",secondTemplate:"Second template output"}));var e=ko.observable("firstTemplate");testNode.innerHTML="<div data-bind='template: { name: chosenTemplate }'></div>",ko.applyBindings({chosenTemplate:e},testNode),expect(testNode.childNodes[0].innerHTML).toEqual("First template output"),e("secondTemplate"),expect(testNode.childNodes[0].innerHTML).toEqual("Second template output")}),it('Should be able to pick template via an observable model property when specified as "name" in conjunction with "foreach"',function(){ko.setTemplateEngine(new dummyTemplateEngine({firstTemplate:"First",secondTemplate:"Second"}));var e=ko.observable("firstTemplate");testNode.innerHTML="<div data-bind='template: { name: chosenTemplate, foreach: [1,2,3] }'></div>",ko.applyBindings({chosenTemplate:e},testNode),expect(testNode.childNodes[0].innerHTML).toEqual("FirstFirstFirst"),e("secondTemplate"),expect(testNode.childNodes[0].innerHTML).toEqual("SecondSecondSecond")}),it("Should be able to pick template as a function of the data item using data-bind syntax, with the binding context available as a second parameter",function(){var e=function(e,t){return expect(t.$parent.anotherProperty).toEqual(456),e.myTemplate};ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"result = [js: childProp]"})),testNode.innerHTML="<div data-bind='template: { name: templateSelectorFunction, data: someProp }'></div>",ko.applyBindings({someProp:{childProp:123,myTemplate:"someTemplate"},templateSelectorFunction:e,anotherProperty:456},testNode),expect(testNode.childNodes[0].innerHTML).toEqual("result = 123")}),it("Should be able to chain templates, rendering one from inside another",function(){ko.setTemplateEngine(new dummyTemplateEngine({outerTemplate:"outer template output, [renderTemplate:innerTemplate]",innerTemplate:"inner template output <span data-bind='text: 123'></span>"})),testNode.innerHTML="<div data-bind='template:\"outerTemplate\"'></div>",ko.applyBindings(null,testNode),expect(testNode.childNodes[0]).toContainHtml("outer template output, inner template output <span>123</span>")}),it("Should rerender chained templates when their dependencies change, without rerendering parent templates",function(){var e=new ko.observable("ABC"),t=0,n=0;ko.setTemplateEngine(new dummyTemplateEngine({outerTemplate:function(){return t++,"outer template output, [renderTemplate:innerTemplate]"},innerTemplate:function(){return n++,e()}})),testNode.innerHTML="<div data-bind='template:\"outerTemplate\"'></div>",ko.applyBindings(null,testNode),expect(testNode.childNodes[0]).toContainHtml("outer template output, abc"),expect(t).toEqual(1),expect(n).toEqual(1),e("DEF"),expect(testNode.childNodes[0]).toContainHtml("outer template output, def"),expect(t).toEqual(1),expect(n).toEqual(2)}),it("Should stop tracking inner observables referenced by a chained template as soon as the chained template output node is removed from the document",function(){var e=ko.observable("some value");ko.setTemplateEngine(new dummyTemplateEngine({outerTemplate:"outer template output, <span id='innerTemplateOutput'>[renderTemplate:innerTemplate]</span>",innerTemplate:"result = [js: childProp()]"})),testNode.innerHTML="<div data-bind='template: { name: \"outerTemplate\", data: someProp }'></div>",ko.applyBindings({someProp:{childProp:e}},testNode),expect(e.getSubscriptionsCount()).toEqual(1),ko.removeNode(document.getElementById("innerTemplateOutput")),expect(e.getSubscriptionsCount()).toEqual(0)}),it("Should handle data-bind attributes from inside templates, regardless of element and attribute casing",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"<INPUT Data-Bind='value:\"Hi\"' />"})),ko.renderTemplate("someTemplate",null,null,testNode),expect(testNode.childNodes[0].value).toEqual("Hi")}),it("Should handle data-bind attributes that include newlines from inside templates",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"<input data-bind='value:\n\"Hi\"' />"})),ko.renderTemplate("someTemplate",null,null,testNode),expect(testNode.childNodes[0].value).toEqual("Hi")}),it("Data binding syntax should be able to reference variables put into scope by the template engine",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"<input data-bind='value:message' />"})),ko.renderTemplate("someTemplate",null,{templateRenderingVariablesInScope:{message:"hello"}},testNode),expect(testNode.childNodes[0].value).toEqual("hello")}),it("Should handle data-bind attributes with spaces around equals sign from inside templates and reference variables",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"<input data-bind = 'value:message' />"})),ko.renderTemplate("someTemplate",null,{templateRenderingVariablesInScope:{message:"hello"}},testNode),expect(testNode.childNodes[0].value).toEqual("hello")}),it("Data binding syntax should be able to use $element in binding value",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"<div data-bind='text: $element.tagName'></div>"})),ko.renderTemplate("someTemplate",null,null,testNode),expect(testNode.childNodes[0]).toContainText("DIV")}),it("Data binding syntax should be able to use $context in binding value to refer to the context object",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"<div data-bind='text: $context.$data === $data'></div>"})),ko.renderTemplate("someTemplate",{},null,testNode),expect(testNode.childNodes[0]).toContainText("true")}),it("Data binding syntax should defer evaluation of variables until the end of template rendering (so bindings can take independent subscriptions to them)",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"<input data-bind='value:message' />[js: message = 'goodbye'; undefined; ]"})),ko.renderTemplate("someTemplate",null,{templateRenderingVariablesInScope:{message:"hello"}},testNode),expect(testNode.childNodes[0].value).toEqual("goodbye")}),it("Data binding syntax should use the template's 'data' object as the viewModel value (so 'this' is set correctly when calling click handlers etc.)",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"<button data-bind='click: someFunctionOnModel'>click me</button>"}));var e={didCallMyFunction:!1,someFunctionOnModel:function(){this.didCallMyFunction=!0}};ko.renderTemplate("someTemplate",e,null,testNode);var t=testNode.childNodes[0];expect(t.tagName).toEqual("BUTTON"),t.click(),expect(e.didCallMyFunction).toEqual(!0)}),it("Data binding syntax should permit nested templates, and only bind inner templates once when using getBindingAccessors",function(){this.restoreAfter(ko.bindingProvider,"instance");var e=ko.bindingProvider.instance;ko.bindingProvider.instance={nodeHasBindings:function(t,n){return t.tagName=="EM"||e.nodeHasBindings(t,n)},getBindingAccessors:function(n,r){return n.tagName=="EM"?{text:function(){return++t.numExternalBindings}}:e.getBindingAccessors(n,r)}},ko.setTemplateEngine(new dummyTemplateEngine({outerTemplate:"Outer <div data-bind='template: { name: \"innerTemplate\", bypassDomNodeWrap: true }'></div>",innerTemplate:"Inner via inline binding: <span data-bind='text: ++numRewrittenBindings'></span>Inner via external binding: <em></em>"}));var t={numRewrittenBindings:0,numExternalBindings:0};testNode.innerHTML="<div data-bind='template: { name: \"outerTemplate\", bypassDomNodeWrap: true }'></div>",ko.applyBindings(t,testNode),expect(t.numRewrittenBindings).toEqual(1),expect(t.numExternalBindings).toEqual(1),expect(testNode.childNodes[0]).toContainHtml("outer <div>inner via inline binding: <span>1</span>inner via external binding: <em>1</em></div>")}),it("Data binding syntax should permit nested templates, and only bind inner templates once when using getBindings",function(){this.restoreAfter(ko.bindingProvider,"instance");var e=ko.bindingProvider.instance;ko.bindingProvider.instance={nodeHasBindings:function(t,n){return t.tagName=="EM"||e.nodeHasBindings(t,n)},getBindings:function(n,r){return n.tagName=="EM"?{text:++t.numExternalBindings}:e.getBindings(n,r)}},ko.setTemplateEngine(new dummyTemplateEngine({outerTemplate:"Outer <div data-bind='template: { name: \"innerTemplate\", bypassDomNodeWrap: true }'></div>",innerTemplate:"Inner via inline binding: <span data-bind='text: ++numRewrittenBindings'></span>Inner via external binding: <em></em>"}));var t={numRewrittenBindings:0,numExternalBindings:0};testNode.innerHTML="<div data-bind='template: { name: \"outerTemplate\", bypassDomNodeWrap: true }'></div>",ko.applyBindings(t,testNode),expect(t.numRewrittenBindings).toEqual(1),expect(t.numExternalBindings).toEqual(2),expect(testNode.childNodes[0]).toContainHtml("outer <div>inner via inline binding: <span>1</span>inner via external binding: <em>2</em></div>")}),it('Should accept a "nodes" option that gives the template nodes',function(){ko.setTemplateEngine(new dummyTemplateEngine({innerTemplate:"the name is [js: name()]"})),testNode.innerHTML="<div data-bind='template: { nodes: testNodes, data: testData, bypassDomNodeWrap: true }'></div>";var e={testNodes:[document.createTextNode("begin"),document.createElement("span"),document.createTextNode("end")],testData:{name:ko.observable("alpha")}};e.testNodes[1].setAttribute("data-bind","template: 'innerTemplate'"),ko.applyBindings(e,testNode),expect(testNode.childNodes[0]).toContainHtml("begin<span>the name is alpha</span>end"),e.testData.name("beta"),expect(testNode.childNodes[0]).toContainHtml("begin<span>the name is beta</span>end")}),it('Should accept a "nodes" option that gives the template nodes, and it can be used in conjunction with "foreach"',function(){testNode.innerHTML="<div data-bind='template: { nodes: testNodes, foreach: testData, bypassDomNodeWrap: true }'></div>";var e=document.createElement("div");e.innerHTML="[<span data-bind='text: name'></span>]";var t={testNodes:e.childNodes,testData:ko.observableArray([{name:ko.observable("alpha")},{name:"beta"},{name:"gamma"}])};t.testNodes[1].setAttribute("data-bind","text: name"),ko.applyBindings(t,testNode),expect(testNode.childNodes[0]).toContainText("[alpha][beta][gamma]"),t.testData.splice(1,1),expect(testNode.childNodes[0]).toContainText("[alpha][gamma]"),e.innerHTML="[Modified, but will not appear in template output because the nodes were already cloned]",t.testData.splice(1,0,{name:"delta"}),expect(testNode.childNodes[0]).toContainText("[alpha][delta][gamma]")}),it('Should interpret "nodes: anyFalseyValue" as being equivalent to supplying an empty node array',function(){testNode.innerHTML="<div data-bind='template: { nodes: null, bypassDomNodeWrap: true }'>Should not use this inline template</div>",ko.applyBindings(null,testNode),expect(testNode.childNodes[0]).toContainHtml("")}),it('Should not allow "nodes: someObservableArray"',function(){testNode.innerHTML="<div data-bind='template: { nodes: myNodes, bypassDomNodeWrap: true }'>Should not use this inline template</div>",expect(function(){ko.applyBindings({myNodes:ko.observableArray()},testNode)}).toThrowContaining('The "nodes" option must be a plain, non-observable array')}),describe("Data binding 'foreach' option",function(){it("Should remove existing content",function(){ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"<span>template content</span>"})),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'><span>existing content</span></div>",ko.applyBindings({myCollection:[{}]},testNode),expect(testNode.childNodes[0]).toContainHtml("<span>template content</span>")}),it("Should render for each item in an array but doesn't rerender everything if you push or splice",function(){var e=new ko.observableArray([{personName:"Bob"},{personName:"Frank"}]);ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"<div>The item is [js: personName]</div>"})),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>",ko.applyBindings({myCollection:e},testNode),expect(testNode.childNodes[0]).toContainHtml("<div>the item is bob</div><div>the item is frank</div>");var t=testNode.childNodes[0].childNodes[0],n=testNode.childNodes[0].childNodes[1];e.push({personName:"Steve"}),expect(testNode.childNodes[0]).toContainHtml("<div>the item is bob</div><div>the item is frank</div><div>the item is steve</div>"),expect(testNode.childNodes[0].childNodes[0]).toEqual(t),expect(testNode.childNodes[0].childNodes[1]).toEqual(n)}),it("Should apply bindings within the context of each item in the array",function(){var e=new ko.observableArray([{personName:"Bob"},{personName:"Frank"}]);ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"The item is <span data-bind='text: personName'></span>"})),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>",ko.applyBindings({myCollection:e},testNode),expect(testNode.childNodes[0]).toContainHtml("the item is <span>bob</span>the item is <span>frank</span>")}),it("Should only bind each group of output nodes once",function(){var e=0;ko.bindingHandlers.countInits={init:function(){e++}},ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"<span data-bind='countInits: true'></span>"})),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>",ko.applyBindings({myCollection:[1,2,3]},testNode),expect(e).toEqual(3)}),it("Should handle templates in which the very first node has a binding",function(){ko.setTemplateEngine(new dummyTemplateEngine({mytemplate:"<div data-bind='text: $data'></div>"})),testNode.innerHTML="<div data-bind=\"template: { name: 'mytemplate', foreach: items }\"></div>";var e=ko.observableArray(["original"]);ko.applyBindings({items:e},testNode),expect(testNode.childNodes[0]).toContainHtml("<div>original</div>"),e(["new"]),expect(testNode.childNodes[0]).toContainHtml("<div>new</div>")}),it("Should handle chained templates in which the very first node has a binding",function(){ko.setTemplateEngine(new dummyTemplateEngine({outerTemplate:"<div data-bind='text: $data'></div>[renderTemplate:innerTemplate]x",innerTemplate:"inner <span data-bind='text: 123'></span>"})),testNode.innerHTML="<div data-bind=\"template: { name: 'outerTemplate', foreach: items }\"></div>";var e=ko.observableArray(["original"]);ko.applyBindings({items:e},testNode),expect(testNode.childNodes[0]).toContainHtml("<div>original</div>inner <span>123</span>x"),e(["new"]),expect(testNode.childNodes[0]).toContainHtml("<div>new</div>inner <span>123</span>x")}),it("Should handle templates in which the very first node has a binding but it does not reference any observables",function(){ko.setTemplateEngine(new dummyTemplateEngine({mytemplate:"<div data-bind='attr: {}'>[js:name()]</div>"})),testNode.innerHTML="<div data-bind=\"template: { name: 'mytemplate', foreach: items }\"></div>";var e={name:ko.observable("a")};ko.applyBindings({items:[e]},testNode),expect(testNode.childNodes[0]).toContainHtml("<div>a</div>"),e.name("b"),expect(testNode.childNodes[0]).toContainHtml("<div>b</div>")}),it("Should apply bindings with an $index in the context",function(){var e=new ko.observableArray([{personName:"Bob"},{personName:"Frank"}]);ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"The item # is <span data-bind='text: $index'></span>"})),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>",ko.applyBindings({myCollection:e},testNode),expect(testNode.childNodes[0]).toContainHtml("the item # is <span>0</span>the item # is <span>1</span>")}),it("Should update bindings that reference an $index if the list changes",function(){var e=new ko.observableArray([{personName:"Bob"},{personName:"Frank"}]);ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"The item <span data-bind='text: personName'></span>is <span data-bind='text: $index'></span>"})),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>",ko.applyBindings({myCollection:e},testNode),expect(testNode.childNodes[0]).toContainHtml("the item <span>bob</span>is <span>0</span>the item <span>frank</span>is <span>1</span>");var t=e.pop();expect(testNode.childNodes[0]).toContainHtml("the item <span>bob</span>is <span>0</span>"),e.unshift(t),expect(testNode.childNodes[0]).toContainHtml("the item <span>frank</span>is <span>0</span>the item <span>bob</span>is <span>1</span>")}),it('Should accept array with "undefined" and "null" items',function(){var e=new ko.observableArray([undefined,null]);ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"The item is <span data-bind='text: String($data)'></span>"})),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>",ko.applyBindings({myCollection:e},testNode),expect(testNode.childNodes[0]).toContainHtml("the item is <span>undefined</span>the item is <span>null</span>")}),it("Should update DOM nodes when a dependency of their mapping function changes",function(){var e=new ko.observable("Steve"),t=new ko.observableArray([{personName:"Bob"},{personName:e},{personName:"Another"}]);ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"<div>The item is [js: ko.utils.unwrapObservable(personName)]</div>"})),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>",ko.applyBindings({myCollection:t},testNode),expect(testNode.childNodes[0]).toContainHtml("<div>the item is bob</div><div>the item is steve</div><div>the item is another</div>");var n=testNode.childNodes[0].childNodes[0];e("Steve2"),expect(testNode.childNodes[0]).toContainHtml("<div>the item is bob</div><div>the item is steve2</div><div>the item is another</div>"),expect(testNode.childNodes[0].childNodes[0]).toEqual(n),expect(e.getSubscriptionsCount()).toEqual(1),t.splice(1,1),expect(testNode.childNodes[0]).toContainHtml("<div>the item is bob</div><div>the item is another</div>"),e("Something else"),expect(e.getSubscriptionsCount()).toEqual(0)}),it("Should treat a null parameter as meaning 'no items'",function(){var e=new ko.observableArray(["A","B"]);ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"hello"})),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>",ko.applyBindings({myCollection:e},testNode),expect(testNode.childNodes[0].childNodes.length).toEqual(2),e(null),expect(testNode.childNodes[0].childNodes.length).toEqual(0)}),it('Should accept an "as" option to define an alias for the iteration variable',function(){var e=new ko.observableArray(["A","B"]);ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"[js:myAliasedItem]"})),testNode.innerHTML='<div data-bind=\'template: { name: "itemTemplate", foreach: myCollection, as: "myAliasedItem" }\'></div>',ko.applyBindings({myCollection:e},testNode),expect(testNode.childNodes[0]).toContainText("AB")}),it("Should stop tracking inner observables when the container node is removed",function(){var e=ko.observable("some value"),t=new ko.observableArray([{obsVal:e},{obsVal:e}]);ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"The item is [js: ko.utils.unwrapObservable(obsVal)]"})),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>",ko.applyBindings({myCollection:t},testNode),expect(e.getSubscriptionsCount()).toEqual(2),ko.removeNode(testNode.childNodes[0]),expect(e.getSubscriptionsCount()).toEqual(0)}),it("Should stop tracking inner observables related to each array item when that array item is removed",function(){var e=ko.observable("some value"),t=new ko.observableArray([{obsVal:e},{obsVal:e}]);ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"The item is [js: ko.utils.unwrapObservable(obsVal)]"})),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>",ko.applyBindings({myCollection:t},testNode),expect(e.getSubscriptionsCount()).toEqual(2),t.splice(1,1),expect(e.getSubscriptionsCount()).toEqual(1),t([]),expect(e.getSubscriptionsCount()).toEqual(0)}),it("Should omit any items whose '_destroy' flag is set (unwrapping the flag if it is observable)",function(){var e=new ko.observableArray([{someProp:1},{someProp:2,_destroy:"evals to true"},{someProp:3},{someProp:4,_destroy:ko.observable(!1)}]);ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"<div>someProp=[js: someProp]</div>"})),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>",ko.applyBindings({myCollection:e},testNode),expect(testNode.childNodes[0]).toContainHtml("<div>someprop=1</div><div>someprop=3</div><div>someprop=4</div>")}),it("Should include any items whose '_destroy' flag is set if you use includeDestroyed",function(){var e=new ko.observableArray([{someProp:1},{someProp:2,_destroy:"evals to true"},{someProp:3}]);ko.setTemplateEngine(new dummyTemplateEngine({itemTemplate:"<div>someProp=[js: someProp]</div>"})),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection, includeDestroyed: true }'></div>",ko.applyBindings({myCollection:e},testNode),expect(testNode.childNodes[0]).toContainHtml("<div>someprop=1</div><div>someprop=2</div><div>someprop=3</div>")}),it("Should be able to render a different template for each array entry by passing a function as template name, with the array entry's binding context available as a second parameter",function(){var e=new ko.observableArray([{preferredTemplate:1,someProperty:"firstItemValue"},{preferredTemplate:2,someProperty:"secondItemValue"}]);ko.setTemplateEngine(new dummyTemplateEngine({firstTemplate:"<div>Template1Output, [js:someProperty]</div>",secondTemplate:"<div>Template2Output, [js:someProperty]</div>"})),testNode.innerHTML="<div data-bind='template: {name: getTemplateModelProperty, foreach: myCollection}'></div>";var t=function(e,t){return expect(t.$parent.anotherProperty).toEqual(123),e.preferredTemplate==1?"firstTemplate":"secondTemplate"};ko.applyBindings({myCollection:e,getTemplateModelProperty:t,anotherProperty:123},testNode),expect(testNode.childNodes[0]).toContainHtml("<div>template1output, firstitemvalue</div><div>template2output, seconditemvalue</div>")}),it("Should update all child contexts and bindings when used with a top-level observable view model",function(){var e=ko.observable({items:["A","B","C"],itemValues:{A:[1,2,3],B:[4,5,6],C:[7,8,9]}}),t=new dummyTemplateEngine({itemTemplate:"<span>The <span data-bind='text: $index'>&nbsp;</span> item <span data-bind='text: $data'>&nbsp;</span> has <span data-bind='template: { name: \"valueTemplate\", foreach: $root.itemValues[$data] }'>&nbsp;</span> </span>",valueTemplate:"<span data-bind='text: $index'>&nbsp;</span>.<span data-bind='text: $data'>&nbsp;</span>,"});t.createJavaScriptEvaluatorBlock=function(e){return"[[js:"+e+"]]"},ko.setTemplateEngine(t),testNode.innerHTML="<div data-bind='template: { name: \"itemTemplate\", foreach: items }'></div>",ko.applyBindings(e,testNode),expect(testNode.childNodes[0]).toContainText("The 0 item A has 0.1,1.2,2.3, The 1 item B has 0.4,1.5,2.6, The 2 item C has 0.7,1.8,2.9, "),e({items:["C","B","A"],itemValues:{A:[1,2,30],B:[4,5,60],C:[7,8,90]}}),expect(testNode.childNodes[0]).toContainText("The 0 item C has 0.7,1.8,2.90, The 1 item B has 0.4,1.5,2.60, The 2 item A has 0.1,1.2,2.30, ")})}),it('Data binding syntax should support "if" condition',function(){ko.setTemplateEngine(new dummyTemplateEngine({myTemplate:"Value: [js: myProp().childProp]"})),testNode.innerHTML='<div data-bind=\'template: { name: "myTemplate", "if": myProp }\'></div>';var e={myProp:ko.observable({childProp:"abc"})};ko.applyBindings(e,testNode),expect(testNode.childNodes[0]).toContainText("Value: abc"),e.myProp(null),expect(testNode.childNodes[0]).toContainText(""),e.myProp({childProp:"def"}),expect(testNode.childNodes[0]).toContainText("Value: def")}),it('Data binding syntax should support "ifnot" condition',function(){ko.setTemplateEngine(new dummyTemplateEngine({myTemplate:"Hello"})),testNode.innerHTML="<div data-bind='template: { name: \"myTemplate\", ifnot: shouldHide }'></div>";var e={shouldHide:ko.observable(!0)};ko.applyBindings(e,testNode),expect(testNode.childNodes[0]).toContainText(""),e.shouldHide(!1),expect(testNode.childNodes[0]).toContainText("Hello"),e.shouldHide(!0),expect(testNode.childNodes[0]).toContainText("")}),it('Data binding syntax should support "if" condition in conjunction with foreach',function(){ko.setTemplateEngine(new dummyTemplateEngine({myTemplate:"Value: [js: myProp().childProp]"})),testNode.innerHTML='<div data-bind=\'template: { name: "myTemplate", "if": myProp, foreach: [$data, $data, $data] }\'></div>';var e={myProp:ko.observable({childProp:"abc"})};ko.applyBindings(e,testNode),expect(testNode.childNodes[0].childNodes[0].nodeValue).toEqual("Value: abc"),expect(testNode.childNodes[0].childNodes[1].nodeValue).toEqual("Value: abc"),expect(testNode.childNodes[0].childNodes[2].nodeValue).toEqual("Value: abc"),e.myProp(null),expect(testNode.childNodes[0]).toContainText(""),e.myProp({childProp:"def"}),expect(testNode.childNodes[0].childNodes[0].nodeValue).toEqual("Value: def"),expect(testNode.childNodes[0].childNodes[1].nodeValue).toEqual("Value: def"),expect(testNode.childNodes[0].childNodes[2].nodeValue).toEqual("Value: def")}),it("Should be able to populate checkboxes from inside templates, despite IE6 limitations",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"<input type='checkbox' data-bind='checked:isChecked' />"})),ko.renderTemplate("someTemplate",null,{templateRenderingVariablesInScope:{isChecked:!0}},testNode),expect(testNode.childNodes[0].checked).toEqual(!0)}),it("Should be able to populate radio buttons from inside templates, despite IE6 limitations",function(){ko.setTemplateEngine(new dummyTemplateEngine({someTemplate:"<input type='radio' name='somename' value='abc' data-bind='checked:someValue' />"})),ko.renderTemplate("someTemplate",null,{templateRenderingVariablesInScope:{someValue:"abc"}},testNode),expect(testNode.childNodes[0].checked).toEqual(!0)}),it("Data binding 'templateOptions' should be passed to template",function(){var e={someAdditionalData:{myAdditionalProp:"someAdditionalValue"},people:new ko.observableArray([{name:"Alpha"},{name:"Beta"}])};ko.setTemplateEngine(new dummyTemplateEngine({myTemplate:"<div>Person [js:name] has additional property [js:templateOptions.myAdditionalProp]</div>"})),testNode.innerHTML="<div data-bind='template: {name: \"myTemplate\", foreach: people, templateOptions: someAdditionalData }'></div>",ko.applyBindings(e,testNode),expect(testNode.childNodes[0]).toContainHtml("<div>person alpha has additional property someadditionalvalue</div><div>person beta has additional property someadditionalvalue</div>")}),it("If the template binding is updated, should dispose any template subscriptions previously associated with the element",function(){var e=ko.observable("some value"),t={subModel:ko.observable({myObservable:e})};ko.setTemplateEngine(new dummyTemplateEngine({myTemplate:"<span>The value is [js:myObservable()]</span>"})),testNode.innerHTML="<div data-bind='template: {name: \"myTemplate\", data: subModel}'></div>",ko.applyBindings(t,testNode),expect(testNode.childNodes[0]).toContainText("The value is some value"),expect(e.getSubscriptionsCount()).toEqual(1);var n=testNode.childNodes[0].childNodes[0];t.subModel({myObservable:e}),expect(testNode.childNodes[0].childNodes[0]).not.toEqual(n),expect(e.getSubscriptionsCount()).toEqual(1)}),it("Should be able to specify a template engine instance using data-bind syntax",function(){ko.setTemplateEngine(new dummyTemplateEngine({theTemplate:"Default output"}));var e=new dummyTemplateEngine({theTemplate:"Alternative output"});testNode.innerHTML="<div data-bind='template: { name: \"theTemplate\", templateEngine: chosenEngine }'></div>",ko.applyBindings({chosenEngine:e},testNode),expect(testNode.childNodes[0]).toContainText("Alternative output")}),it("Should be able to bind $data to an alias using 'as'",function(){ko.setTemplateEngine(new dummyTemplateEngine({myTemplate:"ValueLiteral: [js:item.prop], ValueBound: <span data-bind='text: item.prop'></span>"})),testNode.innerHTML='<div data-bind=\'template: { name: "myTemplate", data: someItem, as: "item" }\'></div>',ko.applyBindings({someItem:{prop:"Hello"}},testNode),expect(testNode.childNodes[0]).toContainText("ValueLiteral: Hello, ValueBound: Hello")}),it('Data-bind syntax should expose parent binding context as $parent if binding with an explicit "data" value',function(){ko.setTemplateEngine(new dummyTemplateEngine({myTemplate:"ValueLiteral: [js:$parent.parentProp], ValueBound: <span data-bind='text: $parent.parentProp'></span>"})),testNode.innerHTML="<div data-bind='template: { name: \"myTemplate\", data: someItem }'></div>",ko.applyBindings({someItem:{},parentProp:"Hello"},testNode),expect(testNode.childNodes[0]).toContainText("ValueLiteral: Hello, ValueBound: Hello")}),it("Data-bind syntax should expose all ancestor binding contexts as $parents",function(){ko.setTemplateEngine(new dummyTemplateEngine({outerTemplate:"<div data-bind='template: { name:\"middleTemplate\", data: middleItem }'></div>",middleTemplate:"<div data-bind='template: { name: \"innerTemplate\", data: innerItem }'></div>",innerTemplate:"(Data:[js:$data.val], Parent:[[js:$parents[0].val]], Grandparent:[[js:$parents[1].val]], Root:[js:$root.val], Depth:[js:$parents.length])"})),testNode.innerHTML="<div data-bind='template: { name: \"outerTemplate\", data: outerItem }'></div>",ko.applyBindings({val:"ROOT",outerItem:{val:"OUTER",middleItem:{val:"MIDDLE",innerItem:{val:"INNER"}}}},testNode),expect(testNode.childNodes[0].childNodes[0]).toContainText("(Data:INNER, Parent:MIDDLE, Grandparent:OUTER, Root:ROOT, Depth:3)")}),it("Should not be allowed to rewrite templates that embed anonymous templates",function(){ko.setTemplateEngine(new dummyTemplateEngine({myTemplate:"<div data-bind='template: { data: someData }'>Childprop: [js: childProp]</div>"})),testNode.innerHTML="<div data-bind='template: { name: \"myTemplate\" }'></div>",expect(function(){ko.applyBindings({someData:{childProp:"abc"}},testNode)}).toThrowContaining("This template engine does not support anonymous templates nested within its templates")}),it("Should not be allowed to rewrite templates that embed control flow bindings",function(){ko.utils.arrayForEach(["if","ifnot","with","foreach",'"if"'," with "],function(e){ko.setTemplateEngine(new dummyTemplateEngine({myTemplate:"<div data-bind='"+e+': "SomeValue"\'>Hello</div>'})),testNode.innerHTML="<div data-bind='template: { name: \"myTemplate\" }'></div>",ko.utils.domData.clear(testNode),expect(function(){ko.applyBindings({someData:{childProp:"abc"}},testNode)}).toThrowContaining("This template engine does not support")})}),it("Data binding syntax should permit nested templates using virtual containers (with arbitrary internal whitespace and newlines)",function(){ko.setTemplateEngine(new dummyTemplateEngine({outerTemplate:'Outer <!-- ko template: \n{ name: "innerTemplate" } \n--><!-- /ko -->',innerTemplate:"Inner via inline binding: <span data-bind='text: \"someText\"'></span>"}));var e={};testNode.innerHTML="<div data-bind='template: { name: \"outerTemplate\" }'></div>",ko.applyBindings(e,testNode),expect(testNode.childNodes[0]).toContainHtml("outer <!-- ko -->inner via inline binding: <span>sometext</span><!-- /ko -->")}),it("Should be able to render anonymous templates using virtual containers",function(){ko.setTemplateEngine(new dummyTemplateEngine),testNode.innerHTML="Start <!-- ko template: { data: someData } -->Childprop: [js: childProp]<!-- /ko --> End",ko.applyBindings({someData:{childProp:"abc"}},testNode),expect(testNode).toContainHtml("start <!-- ko template: { data: somedata } -->childprop: abc<!-- /ko -->end")}),it("Should be able to use anonymous templates that contain first-child comment nodes",function(){ko.setTemplateEngine(new dummyTemplateEngine({})),testNode.innerHTML="start <div data-bind='foreach: [1,2]'><span><!-- leading comment -->hello</span></div>",ko.applyBindings(null,testNode),expect(testNode).toContainHtml('start <div data-bind="foreach: [1,2]"><span><!-- leading comment -->hello</span><span><!-- leading comment -->hello</span></div>')}),it("Should allow anonymous templates output to include top-level virtual elements, and will bind their virtual children only once",function(){delete ko.bindingHandlers.nonexistentHandler;var e=0;ko.bindingHandlers.countInits={init:function(){e++}},testNode.innerHTML="<div data-bind='template: {}'><!-- ko nonexistentHandler: true --><span data-bind='countInits: true'></span><!-- /ko --></div>",ko.applyBindings(null,testNode),expect(e).toEqual(1)}),it("Should be possible to combine template rewriting, foreach, and a node preprocessor",function(){this.restoreAfter(ko.bindingProvider,"instance");var e=ko.bindingProvider.instance,t=function(){};t.prototype=e,ko.bindingProvider.instance=new t,ko.bindingProvider.instance.preprocessNode=function(e){return[e]},ko.setTemplateEngine(new dummyTemplateEngine({})),testNode.innerHTML="<div data-bind='template: { foreach: items }'><button data-bind='text: $data'></button> OK. </div>";var n=ko.observableArray(["Alpha","Beta"]);ko.applyBindings({items:n},testNode),expect(testNode).toContainText("Alpha OK. Beta OK. "),n.shift(),expect(testNode).toContainText("Beta OK. ")}),it("Should not throw errors if trying to apply text to a non-rendered node",function(){ko.setTemplateEngine(new dummyTemplateEngine({myTemplate:"<tr><span data-bind=\"text: 'Some text'\"></span> </tr>"})),testNode.innerHTML="<div data-bind='template: \"myTemplate\"'></div>",ko.applyBindings(null,testNode)}),it("Should be possible to render a template to a document fragment",function(){ko.setTemplateEngine(new dummyTemplateEngine({myTemplate:"<p>myval: [js: myVal]</p>"}));var e=document.createDocumentFragment();ko.renderTemplate("myTemplate",{myVal:123},null,e),expect(e.childNodes.length).toEqual(1),expect(e.childNodes[0].tagName).toEqual("P"),expect(e.childNodes[0]).toContainHtml("myval: 123")})})}.call(root),amdExports})})(this);